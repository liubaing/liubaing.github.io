<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[六八ing的博客]]></title>
  <subtitle><![CDATA[各种扯淡]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liubaing.com/"/>
  <updated>2017-03-10T11:24:15.345Z</updated>
  <id>http://liubaing.com/</id>
  
  <author>
    <name><![CDATA[何帅]]></name>
    <email><![CDATA[liubaing@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JVM参数设置及优化]]></title>
    <link href="http://liubaing.com/2017/03/01/JVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://liubaing.com/2017/03/01/JVM参数设置及优化/</id>
    <published>2017-03-01T08:44:28.000Z</published>
    <updated>2017-03-10T09:49:24.000Z</updated>
    <content type="html"><![CDATA[<p>本文中一些参数基于JDK8，我们在优化过程中，需要同时关注FullGC和YoungGC，尽可能避免stop-the-world。</p>
<h3 id="JVM内存分区">JVM内存分区</h3>
<blockquote>
<p>JVM进程占用内存 = 堆内存 + 线程数*线程栈 + 元空间 + 堆外内存</p>
</blockquote>
<p>线程数可以利用<code>jstack $PID | more</code>观察当前JVM中所有线程，可以优化部分不必要的线程，降低内存使用同时也避免线程切换的开销。</p>
<h5 id="栈Stack">栈Stack</h5>
<p>存储局部变量等，默认为1M</p>
<h5 id="堆Heap">堆Heap</h5>
<p>存储对象实例，包含新生代，老年代</p>
<h5 id="元Metaspace">元Metaspace</h5>
<p>存储类定义</p>
<h5 id="堆外Off-heap">堆外Off-heap</h5>
<p><code>java.nio.*</code>等使用</p>
<a id="more"></a>


<h3 id="内存相关参数">内存相关参数</h3>
<p>这里主要利用<code>jstat -gcutil $PID</code>, <code>jmap -heap $PID</code>, <code>jmap -histo $PID | more</code>几个常用的命令的结果作为优化的参考。</p>
<h5 id="-Xss[m|k]">-Xss<n>[m|k]</n></h5>
<p>每个线程栈大小</p>
<h5 id="-Xms[g|m|k]_or_-XX:InitialHeapSize">-Xms<n>[g|m|k] or -XX:InitialHeapSize</n></h5>
<p>初始堆内存大小</p>
<h5 id="-Xmx[g|m|k]_or_-XX:MaxHeapSize">-Xmx<n>[g|m|k] or -XX:MaxHeapSize</n></h5>
<p>最大堆内存大小</p>
<h5 id="-Xmn[g|m|k]_or_-XX:NewSize_and_-XX:MaxNewSize">-Xmn<n>[g|m|k] or -XX:NewSize and -XX:MaxNewSize</n></h5>
<p>新生代大小，考虑GC时最坏情况，不建议新生代空间大于老年代</p>
<h5 id="-XX:NewRatio=">-XX:NewRatio=<n></n></h5>
<p>老年代与新生代的大小比例</p>
<h5 id="-XX:SurvivorRatio=">-XX:SurvivorRatio=<n></n></h5>
<p>Eden区与Survivor区的大小比例</p>
<h5 id="-XX:MetaspaceSize=[g|m|k]_and_-XX:MaxMetaspaceSize=[g|m|k]">-XX:MetaspaceSize=<n>[g|m|k] and -XX:MaxMetaspaceSize=<n>[g|m|k]</n></n></h5>
<p>元数据大小，堆外分配内存</p>
<h3 id="GC相关参数">GC相关参数</h3>
<h5 id="-XX:+UseParallelGC">-XX:+UseParallelGC</h5>
<p>JDK8默认GC算法</p>
<h5 id="-XX:+UseConcMarkSweepGC">-XX:+UseConcMarkSweepGC</h5>
<p>使用CMS算法</p>
<h5 id="-XX:+UseG1GC">-XX:+UseG1GC</h5>
<p>使用G1算法，生产环境谨慎</p>
<h5 id="-XX:MaxTenuringThreshold=">-XX:MaxTenuringThreshold=<n></n></h5>
<p>新生代中对象存活次数，超过n后提升到老年代</p>
<h5 id="-XX:+PrintGCDetails_and_-XX:+PrintTenuringDistribution">-XX:+PrintGCDetails and -XX:+PrintTenuringDistribution</h5>
<p>打印GC信息，提供优化参考</p>
<h3 id="优化方案">优化方案</h3>
<ol>
<li>注意ArrayList, HashMap, StringBuilder等扩容问题</li>
<li>Thread Safe的对象全局重用，非Thread Safe的对象ThreadLocal重用</li>
<li>局部变量更多采用基础类型</li>
<li>控制长生命周期对象数量，比如连接池、线程池、缓存等</li>
</ol>
<p>参考 <a href="http://www.techpaste.com/2012/02/java-command-line-options-jvm-performance-improvement/" target="_blank" rel="external">用于JVM性能调优的Java命令行选项</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>本文中一些参数基于JDK8，我们在优化过程中，需要同时关注FullGC和YoungGC，尽可能避免stop-the-world。</p>
<h3 id="JVM内存分区">JVM内存分区</h3>
<blockquote>
<p>JVM进程占用内存 = 堆内存 + 线程数*线程栈 + 元空间 + 堆外内存</p>
</blockquote>
<p>线程数可以利用<code>jstack $PID | more</code>观察当前JVM中所有线程，可以优化部分不必要的线程，降低内存使用同时也避免线程切换的开销。</p>
<h5 id="栈Stack">栈Stack</h5>
<p>存储局部变量等，默认为1M</p>
<h5 id="堆Heap">堆Heap</h5>
<p>存储对象实例，包含新生代，老年代</p>
<h5 id="元Metaspace">元Metaspace</h5>
<p>存储类定义</p>
<h5 id="堆外Off-heap">堆外Off-heap</h5>
<p><code>java.nio.*</code>等使用</p>
]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Protocol Buffers 3]]></title>
    <link href="http://liubaing.com/2017/02/23/Protocol-Buffers-3/"/>
    <id>http://liubaing.com/2017/02/23/Protocol-Buffers-3/</id>
    <published>2017-02-23T10:04:02.000Z</published>
    <updated>2017-03-01T08:54:11.000Z</updated>
    <content type="html"><![CDATA[<p>由于接口同时支持<code>application/x-protobuf</code>和<code>application/json</code>两种<code>content-type</code>，所以<code>protobuf-java</code>提供的JSON序列化方案性能也是我们比较关注的。</p>
<p>最近注意到<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="external">Protocol Buffers 3</a>（下称proto3）中对JSON的处理调整为利用Gson实现，尝试升级到proto3，这里简单总结下中间遇到的一些问题。</p>
<h4 id="proto3语法规则">proto3语法规则</h4>
<ul>
<li><p>描述文件头部增加语法声明<code>syntax = &quot;proto3&quot;</code> ，这样<code>protoc</code>会正确编译生成代码。</p>
</li>
<li><p>移除<code>required</code>描述关键字，字段默认是<code>optional</code>。</p>
</li>
<li><p>移除<code>default</code>选项，proto2可以使用<code>default</code>为某一字段指定默认值，但proto3字段的默认值只能根据字段类型由系统决定。</p>
</li>
<li><p>enum类型第一个字段的字段编号tags必须为0。</p>
</li>
<li><p>添加新的字段选项<code>json_name</code>。默认在proto3的JSON格式中字段名将被转换为<code>lowerCamelCase</code>，这个选项被用于自定义字段名。</p>
</li>
</ul>
<a id="more"></a>

<h4 id="JsonFormat注意点"><code>JsonFormat</code>注意点</h4>
<h5 id="反序列化">反序列化</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>HttpInputMessage inputMessage<span class="comment">;</span>
InputStreamReader reader<span class="comment">;</span>
if (MediaType<span class="preprocessor">.APPLICATION</span>_JSON<span class="preprocessor">.isCompatibleWith</span>(contentType)) {
    reader = new InputStreamReader(inputMessage<span class="preprocessor">.getBody</span>(), charset)<span class="comment">;</span>
    JsonFormat<span class="preprocessor">.parser</span>()
            <span class="preprocessor">.ignoringUnknownFields</span>()            //忽略未知字段，避免反序列化抛异常
            <span class="preprocessor">.merge</span>(reader, ex)<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h5 id="序列化">序列化</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>HttpOutputMessage outputMessage<span class="comment">;</span>
OutputStreamWriter outputStreamWriter<span class="comment">;</span>
if (MediaType<span class="preprocessor">.APPLICATION</span>_JSON<span class="preprocessor">.isCompatibleWith</span>(contentType)) {
    outputStreamWriter = new OutputStreamWriter(outputMessage<span class="preprocessor">.getBody</span>(), charset)<span class="comment">;</span>
    JsonFormat<span class="preprocessor">.printer</span>()
            <span class="preprocessor">.includingDefaultValueFields</span>()      //默认值也要序列化，兼容接口定义，int类型默认值<span class="number">0</span>也要输出
            <span class="preprocessor">.preservingProtoFieldNames</span>()        //保留原有字段名，兼容接口定义
            <span class="preprocessor">.omittingInsignificantWhitespace</span>()  //忽略空格和换行
            <span class="preprocessor">.appendTo</span>(message, outputStreamWriter)<span class="comment">;</span>
    outputStreamWriter<span class="preprocessor">.flush</span>()<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h4 id="实践">实践</h4>
<ul>
<li><p>接口升级不要修改已有字段的tags，通常采用追加模式，<code>reserved</code> 关键字用来声明保留字段。</p>
</li>
<li><p>可以合理利用map类型。</p>
</li>
<li><p>了解<a href="https://github.com/grpc" target="_blank" rel="external">gRPC</a></p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>由于接口同时支持<code>application/x-protobuf</code>和<code>application/json</code>两种<code>content-type</code>，所以<code>protobuf-java</code>提供的JSON序列化方案性能也是我们比较关注的。</p>
<p>最近注意到<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="external">Protocol Buffers 3</a>（下称proto3）中对JSON的处理调整为利用Gson实现，尝试升级到proto3，这里简单总结下中间遇到的一些问题。</p>
<h4 id="proto3语法规则">proto3语法规则</h4>
<ul>
<li><p>描述文件头部增加语法声明<code>syntax = &quot;proto3&quot;</code> ，这样<code>protoc</code>会正确编译生成代码。</p>
</li>
<li><p>移除<code>required</code>描述关键字，字段默认是<code>optional</code>。</p>
</li>
<li><p>移除<code>default</code>选项，proto2可以使用<code>default</code>为某一字段指定默认值，但proto3字段的默认值只能根据字段类型由系统决定。</p>
</li>
<li><p>enum类型第一个字段的字段编号tags必须为0。</p>
</li>
<li><p>添加新的字段选项<code>json_name</code>。默认在proto3的JSON格式中字段名将被转换为<code>lowerCamelCase</code>，这个选项被用于自定义字段名。</p>
</li>
</ul>
]]></summary>
    
      <category term="Protobuf" scheme="http://liubaing.com/tags/Protobuf/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP连接状态总结]]></title>
    <link href="http://liubaing.com/2016/12/24/HTTP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/"/>
    <id>http://liubaing.com/2016/12/24/HTTP连接状态总结/</id>
    <published>2016-12-24T09:56:17.000Z</published>
    <updated>2017-03-10T11:23:44.000Z</updated>
    <content type="html"><![CDATA[<p>TCP连接的生命周期，通常会有</p>
<h3 id="三个阶段">三个阶段</h3>
<ol>
<li>TCP三次握手</li>
<li>数据传送</li>
<li>TCP四次挥手</li>
</ol>
<p>从Google上扒了一张详细介绍各个阶段的产生的连接状态图<br><img src="http://7j1y6m.com1.z0.glb.clouddn.com/connection_state.png" alt="TCP状态转换图"></p>
<h3 id="三种数据包">三种数据包</h3>
<ol>
<li>SYN(同步序列编号,Synchronize Sequence Numbers)该标志仅在三次握手建立TCP连接时有效</li>
<li>ACK(确认编号,Acknowledgement Number)是对TCP请求的确认标志</li>
<li>FIN(结束标志,FINish)用来结束一个TCP连接</li>
</ol>
<h3 id="三个问题">三个问题</h3>
<h4 id="SYN_Flood攻击">SYN Flood攻击</h4>
<p>SYN攻击是一个典型的DDoS攻击。<br>在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect)。<br>SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复ACK包，并等待客户的ACK从而建立连接。<br>由于源地址是不存在的，不会再发送ACK确认包，所以服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，资源耗尽（CPU满负荷或内存不足），让正常的业务请求连接不进来。<br>参考<a href="http://tech.uc.cn/?p=1790" target="_blank" rel="external">TCP洪水攻击（SYN Flood）的诊断和处理</a></p>
<h4 id="CLOSE_WAIT">CLOSE_WAIT</h4>
<p>主动关闭的一方发出FIN包，被动关闭的一方响应ACK包，此时被动关闭的一方就进入了CLOSE_WAIT状态。<br>通常，CLOSE_WAIT状态在服务器停留时间很短，如果你发现大量的CLOSE_WAIT状态，那么就意味着被动关闭的一方没有及时发出FIN包，一般有可能是程序没有及时关闭socket。<br>注意 CLOSE_WAIT没有超时参数控制，如果不重启进程，那么这些状态的连接会永远占用资源。</p>
<h4 id="TIME_WAIT">TIME_WAIT</h4>
<p>在关闭连接的时候，先发FIN包的一方执行的是主动关闭，后发FIN包的一方执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长。<br>MSL指的是报文段的最大生存时间，如果报文段在网络活动了MSL时间，还没有被接收，那么会被丢弃。关于MSL的大小，RFC 793协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，以Linux为例，通常是半分钟，两倍的MSL就是一分钟，也就是60秒。<br>比较有效的方案是连接采用keep-alive，尽可能不让服务端主动关闭连接。</p>
]]></content>
    
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nexus私服搭建]]></title>
    <link href="http://liubaing.com/2016/11/08/Nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>http://liubaing.com/2016/11/08/Nexus私服搭建/</id>
    <published>2016-11-08T06:33:26.000Z</published>
    <updated>2017-03-09T08:58:34.000Z</updated>
    <content type="html"><![CDATA[<p>Nexus是Maven仓库管理工具，Team内部之前存在一套，但管理比较混乱，这段时间腾出手来重新搭了一套，把整个过程记录下。</p>
<h5 id="下载解压">下载解压</h5>
<p>我这里出现ssl链接问题，所以加了—no-check-certificate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>cd /opt/
wget --no-check-certificate https://sonatype-download<span class="preprocessor">.global</span><span class="preprocessor">.ssl</span><span class="preprocessor">.fastly</span><span class="preprocessor">.net</span>/nexus/oss/nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>-bundle<span class="preprocessor">.zip</span>
unzip nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>-bundle<span class="preprocessor">.zip</span>
ln -s nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>/ nexus
</pre></td></tr></table></figure>

<h5 id="修改-bashrc文件增加环境变量">修改.bashrc文件增加环境变量</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="setting">NEXUS_HOME=<span class="value"><span class="string">"/opt/nexus"</span></span></span>
</pre></td></tr></table></figure>

<h5 id="配置为Service">配置为Service</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>ln <span class="operator">-s</span> <span class="variable">$NEXUS_HOME</span>/bin/nexus /etc/init.d/nexus
<span class="built_in">cd</span> /etc/init.d/
<span class="built_in">sudo</span> chkconfig --add nexus
<span class="built_in">sudo</span> chkconfig --levels <span class="number">345</span> nexus on
</pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="处理权限">处理权限</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>groupadd nexus
useradd <span class="attribute">-g</span> nexus nexus
cd /opt<span class="subst">/</span>
chown <span class="attribute">-R</span> nexus:nexus nexus
chown <span class="attribute">-R</span> nexus:nexus nexus<span class="subst">-</span><span class="number">2.14</span><span class="number">.1</span><span class="subst">-</span><span class="number">01</span><span class="subst">/</span>
chown <span class="attribute">-R</span> nexus:nexus sonatype<span class="attribute">-work</span><span class="subst">/</span>
</pre></td></tr></table></figure>

<h5 id="配置Nginx代理">配置Nginx代理</h5>
<p>Nexus默认的context path是/nexus，如果使用Nginx代理访问，<br>需要修改<code>$NEXUS_HOME/conf/nexus.properties</code>将<code>nexus-webapp-context-path=/nexus</code>改为<code>nexus-webapp-context-path=/</code>，<br>否则通过Nginx访问Nexus会出现登陆不了的情况。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>http {

    proxy_send_timeout <span class="number">120</span>;
    proxy_<span class="built_in">read</span>_timeout <span class="number">300</span>;
    proxy_buffering    off;
    keepalive_timeout  <span class="number">5</span> <span class="number">5</span>;
    tcp_nodelay        on;

    server {
        listen   *:<span class="number">80</span>;
        server_name  repo.example.com;

        <span class="comment"># allow large uploads of files - refer to nginx documentation</span>
        client_max_body_size <span class="number">1</span>G;

        <span class="comment"># optimize downloading files larger than 1G - refer to nginx doc before adjusting</span>
        <span class="comment">#proxy_max_temp_file_size 2G;</span>

        location / {
            proxy_pass http://localhost:<span class="number">8081</span>/;
            proxy_<span class="keyword">set</span>_header Host <span class="variable">$host</span>;
            proxy_<span class="keyword">set</span>_header X-Real-IP <span class="variable">$remote_addr</span>;
            proxy_<span class="keyword">set</span>_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;
        }
    }
}
</pre></td></tr></table></figure>

<h5 id="启动Nexus服务，通过域名访问">启动Nexus服务，通过域名访问</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">sudo</span> service nexus start
</pre></td></tr></table></figure>

<h5 id="配置LDAP">配置LDAP</h5>
<p>让同学们都有各自权限来使用Nexus，但这个是麻烦SA同学帮忙配置的。需要的同学可以参考 <a href="http://blog.sina.com.cn/s/blog_6b89db7a0101g8na.html" target="_blank" rel="external">Sonatype Nexus的LDAP配置指导书</a></p>
<h5 id="修改settings-xml">修改settings.xml</h5>
]]></content>
    <summary type="html"><![CDATA[<p>Nexus是Maven仓库管理工具，Team内部之前存在一套，但管理比较混乱，这段时间腾出手来重新搭了一套，把整个过程记录下。</p>
<h5 id="下载解压">下载解压</h5>
<p>我这里出现ssl链接问题，所以加了—no-check-certificate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>cd /opt/
wget --no-check-certificate https://sonatype-download<span class="preprocessor">.global</span><span class="preprocessor">.ssl</span><span class="preprocessor">.fastly</span><span class="preprocessor">.net</span>/nexus/oss/nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>-bundle<span class="preprocessor">.zip</span>
unzip nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>-bundle<span class="preprocessor">.zip</span>
ln -s nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>/ nexus
</pre></td></tr></table></figure>

<h5 id="修改-bashrc文件增加环境变量">修改.bashrc文件增加环境变量</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="setting">NEXUS_HOME=<span class="value"><span class="string">"/opt/nexus"</span></span></span>
</pre></td></tr></table></figure>

<h5 id="配置为Service">配置为Service</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>ln <span class="operator">-s</span> <span class="variable">$NEXUS_HOME</span>/bin/nexus /etc/init.d/nexus
<span class="built_in">cd</span> /etc/init.d/
<span class="built_in">sudo</span> chkconfig --add nexus
<span class="built_in">sudo</span> chkconfig --levels <span class="number">345</span> nexus on
</pre></td></tr></table></figure>

]]></summary>
    
      <category term="Maven" scheme="http://liubaing.com/tags/Maven/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用OpenResty解决IP反作弊]]></title>
    <link href="http://liubaing.com/2016/06/25/%E5%88%A9%E7%94%A8OpenResty%E8%A7%A3%E5%86%B3IP%E5%8F%8D%E4%BD%9C%E5%BC%8A/"/>
    <id>http://liubaing.com/2016/06/25/利用OpenResty解决IP反作弊/</id>
    <published>2016-06-25T08:19:29.000Z</published>
    <updated>2016-07-04T08:46:12.000Z</updated>
    <content type="html"><![CDATA[<p>广告投放项目中Nginx起初有通过<code>ngx_http_limit_req_module</code>和<code>ngx_stream_limit_conn_module</code>配置来限制单个IP在同一时间段的访问和并发次数来防止CC攻击，但在解决一些作弊流量上有些力不从心了。</p>
<p>比如有些IP的在没有展示或者展示时间过短的的情况下，模拟客户端(点击触摸参数宏替换)请求广告点击链接，之前这些非法流量是在离线处理才会过滤掉，没有及时的禁止访问，直接导致这些流量可能会被上游DSP反作弊命中影响收入，所以最近着手处理这个问题。</p>
<p>目前的解决思路是，首先收集到异常IP列表入Redis并设置过期时间，在Nginx上利用Lua判断当前IP是否在黑名单中，从而达到反作弊功能。</p>
<a id="more"></a>

<p>确定思路后，在测试环境搭建环境，Google下找到几个方案，对比之后感觉 <a href="http://openresty.org" target="_blank" rel="external">OpenResty</a> 可以满足，里面包含了需要的<code>Nginx</code> <code>Lua</code> <code>Redis</code>模块，且文档比较详细。</p>
<p>具体的安装方法，在 <a href="http://openresty.org" target="_blank" rel="external">OpenResty</a> 有详细的说明，下面简单列出来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="char">$ </span>yum install readline-devel pcre-devel openssl-devel gcc
<span class="char">$ </span>wget <span class="method">https:</span>//openresty.org/download/openresty-<span class="number">1.9</span><span class="number">.15</span><span class="number">.1</span>.tar.gz
<span class="char">$ </span>tar xvf openresty-<span class="number">1.9</span><span class="number">.15</span><span class="number">.1</span>.tar.gz
<span class="char">$ </span>cd openresty-<span class="number">1.9</span><span class="number">.15</span><span class="number">.1</span>
<span class="char">$ </span>./configure
<span class="char">$ </span>make
<span class="char">$ </span>make install
</pre></td></tr></table></figure>

<p>安装之后，会在 <code>/usr/local/openresty</code> 下面生成相关的文件，下面会有一个 <code>/usr/local/openresty/nginx/sbin/nginx</code>，我们可以使用这个来做代理。</p>
<p>修改<code>nginx.conf</code>来让Lua大施拳脚。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">server</span> {
    listen      <span class="number">80</span>;
    server_name xxx;
    location /lua {
            default_type <span class="string">'text/plain'</span>;
            content_by_lua <span class="string">'ngx.say("hello, lua")'</span>;
    }
    location / {
            proxy_pass http:<span class="comment">//127.0.0.1:8080;</span>
            access_log off;
            access_by_lua_file /opt/script/lua/block_ip.lua;
    }
}
</pre></td></tr></table></figure>

<p>启动<code>Nginx</code>，访问//xxx/lua，响应中出现<code>hello, lua</code>说明配置生效，接下来把脚本放到指定目录就应该可以来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="built_in">local</span> redis = <span class="built_in">require</span> <span class="string">"resty.redis"</span>
<span class="built_in">local</span> cache = redis.<span class="built_in">new</span>()
<span class="built_in">local</span> ok , err = cache.connect(cache,<span class="string">"127.0.0.1"</span>,<span class="string">"6381"</span>)
cache:set_timeout(<span class="number">600</span>)

<span class="keyword">if</span> <span class="operator">not</span> ok <span class="keyword">then</span>
  goto Lastend
<span class="function"><span class="keyword">end</span></span>

is_forbidden, err = cache:<span class="built_in">get</span>(<span class="string">"engine:block:ip:"</span>..ngx.var.remote_addr)

<span class="keyword">if</span> is_forbidden == <span class="string">'1'</span> <span class="keyword">then</span>
  ngx.exit(ngx.HTTP_FORBIDDEN)
  goto Lastend
<span class="function"><span class="keyword">end</span></span>

::Lastend::
<span class="built_in">local</span> ok, err = cache:<span class="built_in">close</span>()
</pre></td></tr></table></figure>

<p>异常IP收集入Redis后，访问返回403，IP的key过期后恢复访问，简单的反作弊算是基本完成了，下一步了继续优化。</p>
<hr>
<p>[2016-07-04]更新：</p>
<p>考虑到<code>Redis</code>单点压力，决定利用<code>Nginx</code>共享来做多级缓存，<code>Lua</code>脚本调整后如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="built_in">local</span> redis = <span class="built_in">require</span> <span class="string">"resty.redis"</span>

<span class="comment">--nginx.conf 配置lua_shared_dict RBL 64m;</span>
<span class="built_in">local</span> cache_ngx = ngx.shared.RBL

<span class="comment">--查询ip是否在封禁段内，若在则返回403错误代码</span>
<span class="built_in">local</span> key = <span class="string">"engine:block:ip:"</span>..ngx.var.remote_addr
<span class="built_in">local</span> <span class="built_in">value</span> = cache_ngx:<span class="built_in">get</span>(key)
<span class="keyword">if</span> <span class="built_in">value</span> == <span class="string">'1'</span> <span class="keyword">then</span>
	ngx.<span class="built_in">log</span>(ngx.WARN, <span class="string">"被Nginx缓存命中拦截的IP: "</span> .. key)
	ngx.exit(ngx.HTTP_FORBIDDEN)
<span class="keyword">else</span>
	<span class="built_in">local</span> cache_rds = redis.<span class="built_in">new</span>()
	<span class="built_in">local</span> ok , err = cache_rds.connect(cache_rds, <span class="string">"127.0.0.1"</span>, <span class="string">"6381"</span>)
	<span class="keyword">if</span> <span class="operator">not</span> ok <span class="keyword">then</span>
		ngx.<span class="built_in">log</span>(ngx.WARN, <span class="string">"Redis获取链接异常: "</span> .. err)
  	<span class="keyword">else</span>
  		cache_rds:set_timeout(<span class="number">600</span>)
		<span class="built_in">value</span> = cache_rds:<span class="built_in">get</span>(key)
		<span class="keyword">if</span> <span class="built_in">value</span> == <span class="string">'1'</span> <span class="keyword">then</span>
			ngx.<span class="built_in">log</span>(ngx.WARN, <span class="string">"被Redis缓存命中拦截的IP: "</span> .. key)
			<span class="comment">--回写nginx，设置expires2分钟</span>
			cache_ngx:<span class="built_in">set</span>(key, <span class="built_in">value</span>, <span class="number">120</span>)
			ngx.exit(ngx.HTTP_FORBIDDEN)
		<span class="function"><span class="keyword">end</span></span>
	<span class="function"><span class="keyword">end</span></span>
	<span class="built_in">local</span> ok, err = cache_rds:<span class="built_in">close</span>()
<span class="function"><span class="keyword">end</span></span>
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>广告投放项目中Nginx起初有通过<code>ngx_http_limit_req_module</code>和<code>ngx_stream_limit_conn_module</code>配置来限制单个IP在同一时间段的访问和并发次数来防止CC攻击，但在解决一些作弊流量上有些力不从心了。</p>
<p>比如有些IP的在没有展示或者展示时间过短的的情况下，模拟客户端(点击触摸参数宏替换)请求广告点击链接，之前这些非法流量是在离线处理才会过滤掉，没有及时的禁止访问，直接导致这些流量可能会被上游DSP反作弊命中影响收入，所以最近着手处理这个问题。</p>
<p>目前的解决思路是，首先收集到异常IP列表入Redis并设置过期时间，在Nginx上利用Lua判断当前IP是否在黑名单中，从而达到反作弊功能。</p>
]]></summary>
    
      <category term="Nginx" scheme="http://liubaing.com/tags/Nginx/"/>
    
      <category term="Lua" scheme="http://liubaing.com/tags/Lua/"/>
    
      <category term="Redis" scheme="http://liubaing.com/tags/Redis/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初次接触Go编程踩到的坑]]></title>
    <link href="http://liubaing.com/2016/05/19/%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6Go%E7%BC%96%E7%A8%8B%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://liubaing.com/2016/05/19/初次接触Go编程踩到的坑/</id>
    <published>2016-05-19T09:58:35.000Z</published>
    <updated>2016-05-19T10:51:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近想利用Go来写切图服务，没什么经验，遇到的问题比较多，下面就简单总结下，看到的同学们可以参考下吧。</p>
<h3 id="1-_设置HTTP_response_header不生效">1. 设置HTTP response header不生效</h3>
<p>由于响应的数据格式为JSON，所以想设置下<code>Content-Type : application/json</code>，代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>w<span class="preprocessor">.WriteHeader</span>(http<span class="preprocessor">.StatusOK</span>)
w<span class="preprocessor">.Header</span>()<span class="preprocessor">.Set</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
</pre></td></tr></table></figure>

<p>结果在Header始终看不到期望结果，跟踪源码发现<code>response</code>中有<code>wroteHeader</code>字段标示。<br>得出结论，如果这两行代码都需要调用，就必须让 w.WriteHeader 在所有的 w.Header.Set 之后执行，才能生效。</p>
<a id="more"></a>

<h3 id="2-_执行os-MkdirAll(&quot;xx/xx/&quot;,_0666)_返回_permission_denied错误">2. 执行<code>os.MkdirAll(&quot;xx/xx/&quot;, 0666)</code> 返回 <code>permission denied</code>错误</h3>
<p>在<code>$HOME</code>目录下，本地执行Shell命令<code>mkdir -p xx/xx/</code>却成功创建，更改第二个参数<code>FileMode</code>为<code>os.ModePerm</code>也无济于事。<br>Google各种搜索后，尝试增加了两行代码，解决了问题，但目前还不清楚为什么，待解。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>mask := <span class="keyword">syscall</span>.Umask(<span class="number">0</span>)
defer <span class="keyword">syscall</span>.Umask(mask)
</pre></td></tr></table></figure>

<h3 id="3-_切图后image保存到本地抛出invalid_memory_address_or_nil_pointer_dereference异常">3. 切图后<code>image</code>保存到本地抛出<code>invalid memory address or nil pointer dereference</code>异常</h3>
<p>经过切图后得到<code>thumb image.Image</code>对象，已经定义好保存路径<code>thumbPath string</code>，保存到本地代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>buffer := new(bytes<span class="preprocessor">.Buffer</span>)
if err := jpeg<span class="preprocessor">.Encode</span>(buffer, thumb, nil)<span class="comment">; err != nil {</span>
    log<span class="preprocessor">.Fatalln</span>(<span class="string">"unable to encode image."</span>)
}
_ = ioutil<span class="preprocessor">.WriteFile</span>(thumbPath, buffer<span class="preprocessor">.Bytes</span>(), <span class="number">0666</span>)
</pre></td></tr></table></figure><br>在上传JPG图片是运行良好，但在处理PNG格式的图片时，出现error，解决方案是增加<br><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">import</span> <span class="params">(<span class="variable">_</span><span class="string">"image/png"</span>)</span></span>
</pre></td></tr></table></figure>


<h3 id="4-_保存原图内容为空">4. 保存原图内容为空</h3>
<p>保存原图时，想通过md5得到HASH字符串的文件名，之后再把文件保存在指定目录下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>md5h := md5<span class="preprocessor">.New</span>()
io<span class="preprocessor">.Copy</span>(md5h, file)
name := hex<span class="preprocessor">.EncodeToString</span>(md5h<span class="preprocessor">.Sum</span>([]byte(<span class="string">""</span>)))
</pre></td></tr></table></figure>

<p>结果发现保存的原图内容是0字节，怀疑就是这里把文件流读到末尾了。<br>改造代码就是在保存图片前调用<code>file.Seek(0, 0)</code>，把<code>offset</code>设置为0恢复文件流。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近想利用Go来写切图服务，没什么经验，遇到的问题比较多，下面就简单总结下，看到的同学们可以参考下吧。</p>
<h3 id="1-_设置HTTP_response_header不生效">1. 设置HTTP response header不生效</h3>
<p>由于响应的数据格式为JSON，所以想设置下<code>Content-Type : application/json</code>，代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>w<span class="preprocessor">.WriteHeader</span>(http<span class="preprocessor">.StatusOK</span>)
w<span class="preprocessor">.Header</span>()<span class="preprocessor">.Set</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
</pre></td></tr></table></figure>

<p>结果在Header始终看不到期望结果，跟踪源码发现<code>response</code>中有<code>wroteHeader</code>字段标示。<br>得出结论，如果这两行代码都需要调用，就必须让 w.WriteHeader 在所有的 w.Header.Set 之后执行，才能生效。</p>
]]></summary>
    
      <category term="Go" scheme="http://liubaing.com/tags/Go/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多线程顺序输出字符]]></title>
    <link href="http://liubaing.com/2016/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6/"/>
    <id>http://liubaing.com/2016/01/22/多线程顺序输出字符/</id>
    <published>2016-01-22T05:27:48.000Z</published>
    <updated>2017-03-07T03:08:54.000Z</updated>
    <content type="html"><![CDATA[<p>题目：有多个线程，要求按顺序输出a-z，结果为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[A]</span>
<span class="attr_selector">[Thread-2]</span> <span class="tag">print</span> <span class="attr_selector">[B]</span>
<span class="attr_selector">[Thread-3]</span> <span class="tag">print</span> <span class="attr_selector">[C]</span>
<span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[D]</span>
<span class="attr_selector">[Thread-2]</span> <span class="tag">print</span> <span class="attr_selector">[E]</span>
<span class="attr_selector">[Thread-3]</span> <span class="tag">print</span> <span class="attr_selector">[F]</span>
<span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[G]</span>
…
</pre></td></tr></table></figure>

<a id="more"></a>

<p>实现代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.Queue;
<span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;
<span class="keyword">import</span> java.util.concurrent.Semaphore;

<span class="javadoc">/**
 * 多线程顺序输出字符队列
 *
 *<span class="javadoctag"> @author</span> heshuai
 *<span class="javadoctag"> @version</span> 16/1/20.
 */</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span> {</span>

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">3</span>;

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Queue&lt;Character&gt; CHARACTER_QUEUE = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="string">'Z'</span> - <span class="string">'A'</span> + <span class="number">1</span>);

    <span class="keyword">static</span> {
        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'A'</span>; c &lt;= <span class="string">'Z'</span>; c++) {
            CHARACTER_QUEUE.add(c);
        }
    }

    <span class="keyword">static</span> class Worker extends Thread {

        <span class="keyword">private</span> Semaphore curSemaphore;
        <span class="keyword">private</span> Semaphore nextSemaphore;

        <span class="keyword">public</span> <span class="title">Worker</span>(<span class="keyword">int</span> index, Semaphore curSemaphore, Semaphore nextSemaphore) {
            <span class="keyword">this</span>.setName(<span class="string">"Thread-"</span> + index);
            <span class="keyword">this</span>.curSemaphore = curSemaphore;
            <span class="keyword">this</span>.nextSemaphore = nextSemaphore;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
            <span class="keyword">while</span> (!CHARACTER_QUEUE.isEmpty()) {
                <span class="keyword">try</span> {
                    curSemaphore.acquire();
                    Character character = CHARACTER_QUEUE.poll();
                    <span class="keyword">if</span> (character == <span class="keyword">null</span>) {
                        <span class="keyword">break</span>;
                    }
                    System.out.println(<span class="string">"["</span> + <span class="keyword">this</span>.getName() + <span class="string">"] print ["</span> + character + <span class="string">"]"</span>);
                } <span class="keyword">catch</span> (Exception e) {
                    <span class="comment">//ignore</span>
                } <span class="keyword">finally</span> {
                    nextSemaphore.release();
                }
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Semaphore[] semaphores = <span class="keyword">new</span> Semaphore[THREAD_COUNT];
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) {
            semaphores[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);
        }

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_COUNT; i++) {
            <span class="comment">//先确保Thread-1执行</span>
            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) {
                <span class="keyword">try</span> {
                    semaphores[i - <span class="number">1</span>].acquire();
                } <span class="keyword">catch</span> (Exception e) {
                    <span class="comment">//ignore</span>
                }
            }
            <span class="keyword">if</span> (i &lt; THREAD_COUNT) {
                <span class="keyword">new</span> Worker(i, semaphores[i - <span class="number">1</span>], semaphores[i]).start();
            } <span class="keyword">else</span> {
                <span class="keyword">new</span> Worker(i, semaphores[i - <span class="number">1</span>], semaphores[<span class="number">0</span>]).start();
            }
        }
    }
}
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>题目：有多个线程，要求按顺序输出a-z，结果为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[A]</span>
<span class="attr_selector">[Thread-2]</span> <span class="tag">print</span> <span class="attr_selector">[B]</span>
<span class="attr_selector">[Thread-3]</span> <span class="tag">print</span> <span class="attr_selector">[C]</span>
<span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[D]</span>
<span class="attr_selector">[Thread-2]</span> <span class="tag">print</span> <span class="attr_selector">[E]</span>
<span class="attr_selector">[Thread-3]</span> <span class="tag">print</span> <span class="attr_selector">[F]</span>
<span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[G]</span>
…
</pre></td></tr></table></figure>

]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat优化]]></title>
    <link href="http://liubaing.com/2015/09/09/Tomcat%E4%BC%98%E5%8C%96/"/>
    <id>http://liubaing.com/2015/09/09/Tomcat优化/</id>
    <published>2015-09-09T10:06:36.000Z</published>
    <updated>2017-03-08T10:57:44.000Z</updated>
    <content type="html"><![CDATA[<p><strong>更新</strong>：建议部署APM工具<a href="https://github.com/naver/pinpoint" target="_blank" rel="external">Pinpoint</a>，比较直观分析性能。</p>
<h3 id="分析">分析</h3>
<h4 id="排查JVM">排查JVM</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="preprocessor"># jstat -gcutil $PID            注意GC次数，过多的GC会影响延迟</span>
<span class="preprocessor"># jmap -heap $PID               观察各个分区的内存占用情况</span>
<span class="preprocessor"># jmap -histo $PID | more       注意大对象或者对象实例较多的情况</span>
<span class="preprocessor"># jstack $PID &gt; jstack.txt      观察线程执行状态，出现线程Block，需要特别注意</span>
</pre></td></tr></table></figure>

<p>ThreadDump没什么问题，GC没发现严重问题，只是觉得Eden区内存设置有点紧张</p>
<h4 id="排查负载">排查负载</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="preprocessor"># uptime        观察最近的负载</span>
<span class="preprocessor"># free -g       还有可用内存，注意swap</span>
<span class="preprocessor"># ps auxxwf     各个进程，包括JVM占用资源，可能其他进程的CPU负载过高也会影响响应的延迟，比如日志压缩脚本</span>
<span class="preprocessor"># top           注：按下数字1，观察每个CPU核的负载</span>
<span class="preprocessor"># ss -an | grep :8080 | wc -l   当前端口下的连接数，不区分状态</span>
<span class="preprocessor"># netstat -natl | awk '{print $6}' | sort | uniq -c | sort -n   注意各个状态下的连接数，过多的wait连接影响新的请求进来</span>
</pre></td></tr></table></figure>

<p>发现TIME_WAIT状态的连接比较多，接近配置的连接数上限了，怀疑没有配置keep-alive导致Tomcat主动关闭Connection。</p>
<blockquote>
<p>执行主动关闭的一端进入TIME_WAIT，需要等2倍的MSL时间（通常1分钟）之后才能把状态改为CLOSED。具体参考<a href="http://liubaing.com/2016/12/24/HTTP连接状态总结" target="_blank" rel="external">HTTP连接状态总结</a></p>
</blockquote>
<p>再结合Nginx和Tomcat的日志，开始着手调整。</p>
<h3 id="优化">优化</h3>
<h4 id="Nginx配置keep-alive">Nginx配置keep-alive</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>location / {
    proxy_pass tomcat-upstream;
    proxy_http_version <span class="number">1.1</span>;
    proxy_set_header Connection <span class="string">""</span>;
    <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<h4 id="JVM参数">JVM参数</h4>
<p>在脚本中头部增加一行参数，这里针对JDK8版本的JVM，具体参考<a href="http://liubaing.com/2017/03/01/JVM参数设置及优化" target="_blank" rel="external">JVM参数设置及优化</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment"># vim /usr/local/tomcat/bin/catalina.sh</span>
JAVA_OPTS=<span class="string">"<span class="variable">$JAVA_OPTS</span> -Xms4g -Xmx4g -Xmn2g -XX:SurvivorRatio=16 -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m"</span>
JAVA_OPTS=<span class="string">"<span class="variable">$JAVA_OPTS</span> -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:MaxTenuringThreshold=4"</span>
</pre></td></tr></table></figure>


<h4 id="Connector协议由BIO调整为NIO">Connector协议由BIO调整为NIO</h4>
<h5 id="配置Connector">配置Connector</h5>
<p>同时也参考 <a href="https://tomcat.apache.org/tomcat-8.0-doc/config" target="_blank" rel="external">Tomcat 8 Configuration Reference</a> 修改了线程数和Logs格式，便于统计平均响应时长。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre># vim /usr/local/tomcat/conf/server.xml
&lt;Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol"
            keepAliveTimeout="60000"
            maxKeepAliveRequests="1024"
            &lt;!-- 非异步Servlet时与maxThreads保持一致 --&gt;
            processorCache="128"
            maxThreads="128"
            &lt;!-- 队列大小 --&gt;
            acceptCount="64"
            &lt;!-- 单位毫秒，请求连接超时，keepAliveTimeout参数未设置按此参数 --&gt;
            connectionTimeout="2000"
            redirectPort="8443" /&gt;

&lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
            prefix="localhost_access_log" suffix=".txt"
            pattern="%h %l %u %t &quot;%r&quot; %s %D" /&gt;
</pre></td></tr></table></figure>

<p>这里通过<code>jstack</code>结果分析，决定线程<code>maxThreads</code>参数配置，同时也需要考虑栈空间的分配问题。<br>调整过程中也建议使用ab简单压测下，及时观察调整效果。</p>
]]></content>
    
    
      <category term="Nginx" scheme="http://liubaing.com/tags/Nginx/"/>
    
      <category term="Tomcat" scheme="http://liubaing.com/tags/Tomcat/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排查Java进程CPU占有率高]]></title>
    <link href="http://liubaing.com/2015/07/27/%E6%8E%92%E6%9F%A5Java%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E6%9C%89%E7%8E%87%E9%AB%98/"/>
    <id>http://liubaing.com/2015/07/27/排查Java进程CPU占有率高/</id>
    <published>2015-07-27T08:35:56.000Z</published>
    <updated>2015-07-27T09:16:00.000Z</updated>
    <content type="html"><![CDATA[<p>最近尝试在项目中利用<code>com.sun.management.OperatingSystemMXBean</code>增加些调试信息，发现测试环境Java进程CPU占有率很高，Google后总结一些解决过程。</p>
<p>1.根据top命令，发现占有率高的Java的PID。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="preprocessor">#top</span>
</pre></td></tr></table></figure>


<p>2.找到该PID后，首先显示线程列表，并按照CPU占用高的线程排序。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">#ps</span> <span class="attribute">-mp</span> <span class="variable">$PID</span> <span class="attribute">-o</span> <span class="keyword">THREAD</span>,tid,time <span class="subst">|</span> sort <span class="attribute">-rn</span>
</pre></td></tr></table></figure>


<p>3.然后找到耗时最多的线程TID，将需要的TID转换为16进制格式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">#printf</span> <span class="comment">"%x\n"</span> <span class="char">$T</span>ID
</pre></td></tr></table></figure>


<p>4.打印线程的堆栈信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">#jstack</span> <span class="char">$P</span>ID |grep <span class="char">$0</span>xTID -<span class="class">A</span> <span class="number">30</span>
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="Linux" scheme="http://liubaing.com/tags/Linux/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL JDBC Driver版本Bug]]></title>
    <link href="http://liubaing.com/2015/07/21/MySQL-JDBC-Driver%E7%89%88%E6%9C%ACBug/"/>
    <id>http://liubaing.com/2015/07/21/MySQL-JDBC-Driver版本Bug/</id>
    <published>2015-07-21T09:12:15.000Z</published>
    <updated>2015-07-21T09:53:30.000Z</updated>
    <content type="html"><![CDATA[<p>上周发现线上的CTR信息不准确，影响到广告投放概率。</p>
<p>经过同事的排查发现是数据库实例连接错了，在jdbcUrl中指定的端口是是3307，但实际上是读写3306默认端口的数据库。</p>
<p>跟踪确定是Driver本身的Bug，Google了下官方已经有<a href="https://bugs.mysql.com/bug.php?id=47494" target="_blank" rel="external">相关Bug反馈</a>了，解决方案就是把mysql-connector-java的版本从5.1.9调整为5.1.18。</p>
]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web下文件下载]]></title>
    <link href="http://liubaing.com/2014/12/10/Web%E4%B8%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <id>http://liubaing.com/2014/12/10/Web下文件下载/</id>
    <published>2014-12-10T02:45:20.000Z</published>
    <updated>2014-12-10T11:19:16.000Z</updated>
    <content type="html"><![CDATA[<p>下载中文名文件，这个场景在很多Web下经常遇到。</p>
<p>普遍思路，保存文件重命名，记录下原文件名，待用户下载时，response header种设置下原文件名。</p>
<p>需要注意的是，考虑到浏览器兼容问题，文件名不仅要URLEncode编码处理，还需要遵循<a href="http://tools.ietf.org/html/rfc2231" target="_blank" rel="external">RFC 2231</a>，参数Key后增加星号，Value前面为字符集和单引号中的语言，比如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Content-disposition: attachment;filename<span class="variable">*=</span>utf-<span class="number">8</span><span class="string">'zh_cn'</span><span class="variable">%e4</span><span class="variable">%b8</span><span class="variable">%ad</span><span class="variable">%e6</span><span class="variable">%96</span><span class="variable">%87</span>.pdf
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的单例模式]]></title>
    <link href="http://liubaing.com/2014/10/19/Java%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liubaing.com/2014/10/19/Java中的单例模式/</id>
    <published>2014-10-19T10:28:54.000Z</published>
    <updated>2017-03-09T08:58:34.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式是Java设计模式中相当经典的了，平时工作接触的也只有懒汉、饿汉之类的，之前阿里面试中也被问到这个问题，今天就总结一下。</p>
<h4 id="饿汉式">饿汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>一般不希望在类加载时就创建对象，改进后：</p>
<h4 id="简单实现线程安全的懒汉式">简单实现线程安全的懒汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> synchronized Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>上面例子的性能不太理想，其实只需第一次调用时同步，利用JDK1.5中volatile关键字改进后：</p>
<a id="more"></a>

<h4 id="利用volatile的懒汉式">利用volatile的懒汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            synchronized (Singleton.class) {
                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
                    instance = <span class="keyword">new</span> Singleton();
                }
            }
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<h4 id="利用枚举类">利用枚举类</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> Singleton {
    INSTANCE;
}
</pre></td></tr></table></figure>

<h4 id="利用内部类机制实现">利用内部类机制实现</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {

    <span class="keyword">private</span> <span class="title">Singleton</span>() { }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> SingletonHolder {
        <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> SingletonHolder.INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>总结下，尽管上面列举一些方法实现单例，但还是不完全能保证，还需要注意反序列化和反射。个人推荐枚举方式，代码量简介而且很好利用JVM。</p>
]]></content>
    <summary type="html"><![CDATA[<p>单例模式是Java设计模式中相当经典的了，平时工作接触的也只有懒汉、饿汉之类的，之前阿里面试中也被问到这个问题，今天就总结一下。</p>
<h4 id="饿汉式">饿汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>一般不希望在类加载时就创建对象，改进后：</p>
<h4 id="简单实现线程安全的懒汉式">简单实现线程安全的懒汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> synchronized Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>上面例子的性能不太理想，其实只需第一次调用时同步，利用JDK1.5中volatile关键字改进后：</p>
]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中常用的时间格式化注意点]]></title>
    <link href="http://liubaing.com/2014/09/18/Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://liubaing.com/2014/09/18/Java中常用的时间格式化注意点/</id>
    <published>2014-09-18T09:29:24.000Z</published>
    <updated>2017-03-09T08:58:34.000Z</updated>
    <content type="html"><![CDATA[<p>平时工作中或多或少都会遇到时间格式化的问题，传统思路都利用<code>java.text.SimpleDateFormat</code>，然后根据业务场景写几个Pattern去处理。</p>
<p>之前接触到项目中一般都会提供一个工具类，既然是工具类，那就按套路了，上面声明几个不同格式的Pattern实例，下面写几个static方法，然后处理下异常之类的。</p>
<p>这样的好处是避免方法调用时去new SimpleDateFormat，从而创建大量的实例对象，毕竟SimpleDateFormat类初始化代价不小，父类DateFormat中成员变量包含Calendar等。</p>
<p>但恰恰就因为这个成员变量，并且format方法又没有同步，所以这个工具类在多线程下风险很高。</p>
<a id="more"></a>

<p>这个问题在网上也看到很多解决方案，参考JDK中注释。</p>
<blockquote>
<p> Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally</p>
</blockquote>
<h4 id="同步SimpleDateFormat对象">同步SimpleDateFormat对象</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) <span class="keyword">throws</span> ParseException {
    <span class="keyword">synchronized</span>(sdf) {
        <span class="keyword">return</span> sdf.format(date);
    }
}
</pre></td></tr></table></figure><br>同步随之而来就是阻塞</p>
<h4 id="使用ThreadLocal">使用ThreadLocal</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> final String FULL_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;
<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();

<span class="keyword">public</span> <span class="keyword">static</span> SimpleDateFormat <span class="title">getDateFormat</span>() {
    SimpleDateFormat dateFormat = threadLocal.<span class="keyword">get</span>();
    <span class="keyword">if</span> (dateFormat == <span class="keyword">null</span>) {
        dateFormat = <span class="keyword">new</span> SimpleDateFormat(FULL_DATE_FORMAT);
        threadLocal.<span class="keyword">set</span>(dateFormat);
    }
    <span class="keyword">return</span> dateFormat;
}

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) throws ParseException {
    <span class="keyword">return</span> getDateFormat().format(date);
}
</pre></td></tr></table></figure><br>共享变量变成了线程私有</p>
<h4 id="使用Joda-Time类库">使用Joda-Time类库</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FULL_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(DateTime dateTime) {
    <span class="keyword">return</span> dateTime.toString(FULL_DATE_FORMAT);
}
</pre></td></tr></table></figure><br>对用户自定义Pattern，Joda在解析并创建<code>org.joda.time.format.DateTimeFormatter</code>会Cache，不用过于担心性能问题，当然也自己手动去Cache，因为DateTime有多个toString()重载方法。</p>
]]></content>
    <summary type="html"><![CDATA[<p>平时工作中或多或少都会遇到时间格式化的问题，传统思路都利用<code>java.text.SimpleDateFormat</code>，然后根据业务场景写几个Pattern去处理。</p>
<p>之前接触到项目中一般都会提供一个工具类，既然是工具类，那就按套路了，上面声明几个不同格式的Pattern实例，下面写几个static方法，然后处理下异常之类的。</p>
<p>这样的好处是避免方法调用时去new SimpleDateFormat，从而创建大量的实例对象，毕竟SimpleDateFormat类初始化代价不小，父类DateFormat中成员变量包含Calendar等。</p>
<p>但恰恰就因为这个成员变量，并且format方法又没有同步，所以这个工具类在多线程下风险很高。</p>
]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用浏览器下调试]]></title>
    <link href="http://liubaing.com/2014/07/26/%E5%B8%B8%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%B0%83%E8%AF%95/"/>
    <id>http://liubaing.com/2014/07/26/常用浏览器下调试/</id>
    <published>2014-07-26T07:41:31.000Z</published>
    <updated>2015-09-09T04:48:27.000Z</updated>
    <content type="html"><![CDATA[<p>2015-9-9更新：<br>Android设备进入开发者选项，启用USB调试后，Terminal输入</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>heshuai-<span class="constant">MacBookPro</span><span class="symbol">:~</span> heshuai<span class="variable">$ </span>adb devices
<span class="constant">List</span> of devices attached
<span class="number">01</span>ce8d6a1858745f	device
</pre></td></tr></table></figure><br>检查设备是否成功连接，然后在Chrome 45在地址栏输入 <code>chrome://inspect/</code></p>
<p><img src="http://7j1y6m.com1.z0.glb.clouddn.com/chrome-inspect.png" alt="chrome://inspect/"><br>应该能看到当前连接的设备，找到要调试页面，点击inspect即可</p>
<p><em>注：无需安装Chrome（Android 版）</em></p>
<hr>
<p><strong>Safari</strong>下显示开发者调试工具方法:<br>Preferences - Advanced - Show Develop menu in menu bar</p>
<p><strong>Firefox</strong>本身包含开发者工具，当然Firebug插件大家更常用。</p>
<p><strong>Chrome</strong>下默认的Inspect Element(以下测试均在Chrome Version 36.0.1985.125下)</p>
<h2 id="Console">Console</h2>
<p>使用alert调试在迭代输出时很不方便，这时利用log可以很直观的观察运行状态。</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&gt; console.<span class="keyword">log</span>(<span class="string">'hello world'</span>);
  hello world
&gt; console.<span class="keyword">warn</span>(<span class="string">'warning info'</span>);
&gt; console.<span class="keyword">warn</span>(<span class="string">'error message'</span>)
</pre></td></tr></table></figure><br>平时在Sources标签下对JS方法设置断点Debug时，可以查看作用域内的变量，也可以利用在Console中直接输入变量名查看。</p>
<a id="more"></a>

<h2 id="Emulation">Emulation</h2>
<p>用来调试移动网站的利器，可以模拟移动设备分辨率，UA等，还可以模拟传感器，比如经纬度。</p>
<h2 id="Network">Network</h2>
<p>在这里罗列了当前页所有的HTTP请求，注意Status和Timeline用来作为优化请求的参考标准。<br>点击每条请求能看到请求头、请求参数、响应头、响应内容等信息，比如AJAX请求中比较关注的Content-Type字段。</p>
<h2 id="Resources">Resources</h2>
<p>一般常用就是Cookies标签，可以手动清除部分Cookie。<br>现在很多站点也开始采用H5中的Storage，在这里也可以查看并手动编辑。</p>
<h2 id="Elements">Elements</h2>
<p>查看页面节点信息，可以手动调整DOM，也可以更改CSS，观察渲染样式，查看节点监听事件。</p>
]]></content>
    <summary type="html"><![CDATA[<p>2015-9-9更新：<br>Android设备进入开发者选项，启用USB调试后，Terminal输入</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>heshuai-<span class="constant">MacBookPro</span><span class="symbol">:~</span> heshuai<span class="variable">$ </span>adb devices
<span class="constant">List</span> of devices attached
<span class="number">01</span>ce8d6a1858745f	device
</pre></td></tr></table></figure><br>检查设备是否成功连接，然后在Chrome 45在地址栏输入 <code>chrome://inspect/</code></p>
<p><img src="http://7j1y6m.com1.z0.glb.clouddn.com/chrome-inspect.png" alt="chrome://inspect/"><br>应该能看到当前连接的设备，找到要调试页面，点击inspect即可</p>
<p><em>注：无需安装Chrome（Android 版）</em></p>
<hr>
<p><strong>Safari</strong>下显示开发者调试工具方法:<br>Preferences - Advanced - Show Develop menu in menu bar</p>
<p><strong>Firefox</strong>本身包含开发者工具，当然Firebug插件大家更常用。</p>
<p><strong>Chrome</strong>下默认的Inspect Element(以下测试均在Chrome Version 36.0.1985.125下)</p>
<h2 id="Console">Console</h2>
<p>使用alert调试在迭代输出时很不方便，这时利用log可以很直观的观察运行状态。</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&gt; console.<span class="keyword">log</span>(<span class="string">'hello world'</span>);
  hello world
&gt; console.<span class="keyword">warn</span>(<span class="string">'warning info'</span>);
&gt; console.<span class="keyword">warn</span>(<span class="string">'error message'</span>)
</pre></td></tr></table></figure><br>平时在Sources标签下对JS方法设置断点Debug时，可以查看作用域内的变量，也可以利用在Console中直接输入变量名查看。</p>
]]></summary>
    
      <category term="Android" scheme="http://liubaing.com/tags/Android/"/>
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP常见乱码问题]]></title>
    <link href="http://liubaing.com/2014/06/27/HTTP%E5%B8%B8%E8%A7%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://liubaing.com/2014/06/27/HTTP常见乱码问题/</id>
    <published>2014-06-27T07:42:03.000Z</published>
    <updated>2017-03-10T10:02:45.000Z</updated>
    <content type="html"><![CDATA[<p>众所周知，乱码问题源于编码不一致，往往在平时开发中容易忽略指明编码，而依赖于默认编码。</p>
<p>比如使用Spring MVC时需要配置<code>org.springframework.http.converter.StringHttpMessageConverter</code>的defaultCharset；<br>还有使用HttpClient时注意响应中ByteArray反序列化时也要指明charsetName，否则读取JVM参数file.encoding。</p>
<p>总结下就是一般输入输出流尽量指明编码，防止出现环境不一样导致乱码问题。</p>
]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[龙泉驾校约车脚本]]></title>
    <link href="http://liubaing.com/2014/06/18/%E9%BE%99%E6%B3%89%E9%A9%BE%E6%A0%A1%E7%BA%A6%E8%BD%A6%E8%84%9A%E6%9C%AC/"/>
    <id>http://liubaing.com/2014/06/18/龙泉驾校约车脚本/</id>
    <published>2014-06-18T08:20:49.000Z</published>
    <updated>2014-09-19T03:08:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近该学科目二，可一连几天都约不上车，开始琢磨写个脚本，看有没有效果。<br><a id="more"></a></p>
<p>抱怨驾校也是徒劳，谁让当时图便宜呢。脚本也是参考了其他同学的代码，调整后不是特别完善，不过龙泉的校友还是可以参考。</p>
<p>下面是执行脚本，其中有些参数根据自己情况填写：</p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="comment"># !/usr/bin/python</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> lqjx
<span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

logging.basicConfig(level=logging.DEBUG,
                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,
                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>)

<span class="comment">#约车时段，全部、上午8-12、下午1-5、晚上5-8</span>
xnsd = (<span class="string">"-1"</span>, <span class="string">"812"</span>, <span class="string">"15"</span>, <span class="string">"58"</span>)
<span class="comment">#指定想约的教练</span>
jlcbh = <span class="string">""</span>
uname = <span class="string">""</span>
passwd = <span class="string">""</span>

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    lq = lqjx.LQJX()
    <span class="keyword">try</span>:
        <span class="keyword">if</span> lq.login(uname, passwd):
            <span class="keyword">while</span> <span class="number">1</span>:
                cars = lq.get_bookable_car(xnsd[<span class="number">1</span>])
                <span class="keyword">if</span> <span class="string">'null_0'</span> <span class="keyword">in</span> cars:
                    logging.info(<span class="string">'没到时间或者没有可预订车辆！'</span>)
                <span class="keyword">else</span>:
                    result = lq.order_car(xnsd[<span class="number">1</span>], jlcbh)
                    <span class="keyword">print</span> result
                    <span class="keyword">if</span> <span class="string">u'成功'</span> <span class="keyword">in</span> result:
                        logging.info(<span class="string">'\n 预定成功！'</span>)
                        sys.exit(<span class="number">0</span>)
                <span class="comment">#增加间隔时间，防止频繁请求，账号被封</span>
                time.sleep(<span class="number">30</span>)
    <span class="keyword">except</span> KeyboardInterrupt:
        lq.logout()
        logging.info(<span class="string">'退出约车系统！'</span>)
</pre></td></tr></table></figure>

<p>下面是核心模块：</p>
<p><a id="more"></a></p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="code"><pre><span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> requests
<span class="keyword">import</span> datetime
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

LQJX_HOST = <span class="string">"http://106.37.230.254:81"</span>
lq_session = requests.Session()


<span class="class"><span class="keyword">class</span> <span class="title">LQJX</span>:</span>

    header = {
        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36'</span>
    }

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        <span class="keyword">pass</span>

    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self, uname, passwd)</span>:</span>
        post_data = {
            <span class="string">'__VIEWSTATE'</span>: <span class="string">'/wEPDwUKMTg0NDI4MDE5OGRkj8OrkkOlfYqdhxkeEVV4GsZ6FLw0IioIcl+nbwqoGbo='</span>,
            <span class="string">'__EVENTVALIDATION'</span>: <span class="string">'/wEWBgKF6pivDAKl1bKzCQK1qbSRCwLoyMm8DwLi44eGDAKAv7D9Co04a1vpmJ/QuWDi2GFypJ8LBXRdxHsgxKaj/eIzgMJ6'</span>,
            <span class="string">'txtUserName'</span>: uname,
            <span class="string">'txtPassword'</span>: passwd,
            <span class="string">'BtnLogin'</span>: <span class="string">'登  录'</span>,
            <span class="string">'rcode'</span>: <span class="string">''</span>
        }
        result = lq_session.post(LQJX_HOST + <span class="string">'/login.aspx'</span>, data=post_data, headers=self.header)
        <span class="keyword">if</span> <span class="string">'zhxx.aspx'</span> <span class="keyword">in</span> result.text:
            logging.info(<span class="string">"登录成功!"</span>)
            flag = <span class="keyword">True</span>
        <span class="keyword">else</span>:
            logging.error(<span class="string">"登录失败，请检查账号状态或请求参数!"</span>)
            flag = <span class="keyword">False</span>
        <span class="keyword">return</span> flag

    <span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">(self)</span>:</span>
        lq_session.get(LQJX_HOST + <span class="string">'/Login.aspx?LoginOut=true'</span>, headers=self.header)

    <span class="function"><span class="keyword">def</span> <span class="title">order_car</span><span class="params">(self, xnsd, jlcbh)</span>:</span>
        query_param = {
            <span class="string">'jlcbh'</span>: jlcbh,  <span class="comment">#教练场编号</span>
            <span class="string">'yyrqbegin'</span>: str(datetime.date.today() + datetime.timedelta(<span class="number">13</span>)).replace(<span class="string">'-'</span>, <span class="string">''</span>),  <span class="comment">#预约14天后</span>
            <span class="string">'xnsd'</span>: xnsd,  <span class="comment">#时段 -1  812  15  58</span>
            <span class="string">'trainType'</span>: <span class="string">'3'</span>,  <span class="comment">#原地1 道路3 实际4</span>
            <span class="string">'type'</span>: <span class="string">'km2Car2'</span>,  <span class="comment">#约车类型 科目二km2Car2</span>
            <span class="string">'_'</span>: int(time.time())  <span class="comment">#时间戳</span>
        }
        <span class="keyword">return</span> lq_session.get(LQJX_HOST + <span class="string">"/Tools/km2.aspx?"</span>, params=query_param, headers=self.header).text

    <span class="function"><span class="keyword">def</span> <span class="title">get_bookable_car</span><span class="params">(self, xnsd)</span>:</span>
        base_url = LQJX_HOST + <span class="string">"/Tools/km2.aspx?date="</span> + str(datetime.datetime.now())
        query_param = {
            <span class="string">'filters[yyrq]'</span>: str(datetime.date.today() + datetime.timedelta(<span class="number">13</span>)).replace(<span class="string">'-'</span>, <span class="string">''</span>),
            <span class="string">'filters[xnsd]'</span>: xnsd,
            <span class="string">'filters[xllxid]'</span>: <span class="string">'3'</span>,
            <span class="string">'filters[type]'</span>: <span class="string">'km2Car'</span>,
            <span class="string">'filters[cnbh]'</span>: <span class="string">''</span>, <span class="comment">#场内编号，不填写则为全部</span>
            <span class="string">'pageno'</span>: <span class="string">'1'</span>,
            <span class="string">'pagesize'</span>: <span class="string">'30'</span>,
            <span class="string">'_'</span>: int(time.time())
        }
        <span class="keyword">return</span> lq_session.get(base_url, params=query_param).text

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="keyword">pass</span>
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>最近该学科目二，可一连几天都约不上车，开始琢磨写个脚本，看有没有效果。<br><!--more--></p>
<p>抱怨驾校也是徒劳，谁让当时图便宜呢。脚本也是参考了其他同学的代码，调整后不是特别完善，不过龙泉的校友还是可以参考。</p>
<p>下面是执行脚本，其中有些参数根据自己情况填写：</p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="comment"># !/usr/bin/python</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> lqjx
<span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

logging.basicConfig(level=logging.DEBUG,
                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,
                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>)

<span class="comment">#约车时段，全部、上午8-12、下午1-5、晚上5-8</span>
xnsd = (<span class="string">"-1"</span>, <span class="string">"812"</span>, <span class="string">"15"</span>, <span class="string">"58"</span>)
<span class="comment">#指定想约的教练</span>
jlcbh = <span class="string">""</span>
uname = <span class="string">""</span>
passwd = <span class="string">""</span>

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    lq = lqjx.LQJX()
    <span class="keyword">try</span>:
        <span class="keyword">if</span> lq.login(uname, passwd):
            <span class="keyword">while</span> <span class="number">1</span>:
                cars = lq.get_bookable_car(xnsd[<span class="number">1</span>])
                <span class="keyword">if</span> <span class="string">'null_0'</span> <span class="keyword">in</span> cars:
                    logging.info(<span class="string">'没到时间或者没有可预订车辆！'</span>)
                <span class="keyword">else</span>:
                    result = lq.order_car(xnsd[<span class="number">1</span>], jlcbh)
                    <span class="keyword">print</span> result
                    <span class="keyword">if</span> <span class="string">u'成功'</span> <span class="keyword">in</span> result:
                        logging.info(<span class="string">'\n 预定成功！'</span>)
                        sys.exit(<span class="number">0</span>)
                <span class="comment">#增加间隔时间，防止频繁请求，账号被封</span>
                time.sleep(<span class="number">30</span>)
    <span class="keyword">except</span> KeyboardInterrupt:
        lq.logout()
        logging.info(<span class="string">'退出约车系统！'</span>)
</pre></td></tr></table></figure>

<p>下面是核心模块：</p>
<p>]]></summary>
    
      <category term="Python" scheme="http://liubaing.com/tags/Python/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[世界杯直播]]></title>
    <link href="http://liubaing.com/2014/06/15/%E4%B8%96%E7%95%8C%E6%9D%AF%E7%9B%B4%E6%92%AD/"/>
    <id>http://liubaing.com/2014/06/15/世界杯直播/</id>
    <published>2014-06-15T03:10:39.000Z</published>
    <updated>2016-11-10T08:36:22.000Z</updated>
    <content type="html"><![CDATA[<p>感谢世界杯给我们带来如此精彩的比赛，感谢CCTV节目组和解说嘉宾，更要感谢我们身边那个支持我们熬夜看球的人，但不用谢我，我只是搬运工。<br><a id="more"></a></p>
<iframe height="408" width="510" src="http://static.youku.com/v1.0.0550/v/swf/livePlayer.swf?autoplay=1&showlogo=0&channel=204" frameborder="0" allowfullscreen></iframe>

<p>今天是父亲节，在此借助世界杯祝愿天下所有父亲身体健康，感谢生命中有您的陪伴！</p>
]]></content>
    <summary type="html"><![CDATA[<p>感谢世界杯给我们带来如此精彩的比赛，感谢CCTV节目组和解说嘉宾，更要感谢我们身边那个支持我们熬夜看球的人，但不用谢我，我只是搬运工。<br>]]></summary>
    
      <category term="扯淡" scheme="http://liubaing.com/categories/%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[翻墙]]></title>
    <link href="http://liubaing.com/2014/06/13/%E7%BF%BB%E5%A2%99/"/>
    <id>http://liubaing.com/2014/06/13/翻墙/</id>
    <published>2014-06-13T08:38:14.000Z</published>
    <updated>2016-11-10T08:36:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近Google访问不了，各种403和连接被重置。<br><a id="more"></a><br>这给平时工作带来很大的不便，至于原因大家心知肚明。</p>
<p>之前由于改过hosts，遇到Google被墙对自己影响不大，但这次彻底歇菜了。</p>
<p>选择VPN还得取决所在网络环境，L2TP方式经常连接不上，所以暂时先Pass。看微博上有推荐用SSH代理，去淘宝上搜了一家，10块一月，感觉价格可以接受，还是香港主机，下单吧。</p>
<p>跟大家分享Mac下的方法，首先打开终端输入</p>
<p><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ssh <span class="attribute">-qTfnNv</span> <span class="attribute">-D</span> <span class="number">7070</span> username@host
</pre></td></tr></table></figure><br>输入密码后在网络设置中增加代理，这里选择SOCKS Proxy，输入127.0.0.1:7070后点击应用。</p>
<p><img src="http://liubaing.qiniudn.com/ssh_proxy.jpeg" alt="增加代理"></p>
<p>现在，打开浏览器试试吧！</p>
<hr>
<p>2014-6-19更新：</p>
<p>提供新版<a href="http://liubaing.qiniudn.com/hosts" target="_blank" rel="external">hosts</a>下载，大家自测。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近Google访问不了，各种403和连接被重置。<br>]]></summary>
    
      <category term="VPN" scheme="http://liubaing.com/tags/VPN/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git日常操作]]></title>
    <link href="http://liubaing.com/2014/05/02/Git%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/"/>
    <id>http://liubaing.com/2014/05/02/Git日常操作/</id>
    <published>2014-05-02T07:05:24.000Z</published>
    <updated>2017-03-06T03:34:53.000Z</updated>
    <content type="html"><![CDATA[<p>平时使用git依赖于IDE图形化界面插件，用起来倒没什么问题，但觉得还是有必要总结下常用的git命令，<a href="http://git-scm.com/book/zh" target="_blank" rel="external">点击查看Git中文文档</a>。</p>
<ol>
<li>一般我们clone已有的项目，默认就是git协议，URL后面可以指定目录：<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>liubaing/galaxy.git galaxy
</pre></td></tr></table></figure>

</li>
</ol>
<p>如果本地已经存在的项目</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git init
</pre></td></tr></table></figure>

<p>这时我们发现本地仓库有个隐藏目录.git，里面通常会有：</p>
<p>工作目录(working directory)我们实际持有的文件；<br>缓存区(index/stage)临时保存我们所做的修改；<br>HEAD指向我们最后一次提交的结果。</p>
<p>整个变化过程是这样的：working directory -&gt; “git add” -&gt; index -&gt; “git commit” -&gt; HEAD</p>
<a id="more"></a>


<ol>
<li>本地默认会创建一个master分支，拿平时开发项目为例，我们还需要建立MS分支：<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>$ git checkout <span class="attribute">-b</span> vs<span class="attribute">-ezine</span><span class="subst">-</span><span class="number">4.2</span><span class="number">.0</span><span class="attribute">-MS20140702</span> <span class="variable">#branch</span>为要切换的目的分支
Switched <span class="keyword">to</span> a <span class="literal">new</span> branch <span class="string">'vs-ezine-4.2.0-MS20140702'</span>
</pre></td></tr></table></figure>

</li>
</ol>
<p>现在我们来看下本地分支:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$ git branch <span class="attribute">-av</span> 查看所有分支，PS大家表邪恶
  master
<span class="subst">*</span> vs<span class="attribute">-ezine</span><span class="subst">-</span><span class="number">4.2</span><span class="number">.0</span><span class="attribute">-MS20140702</span>
</pre></td></tr></table></figure>

<p>开发过程中需要提交时：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="variable">$ </span>git mv 重命名，这块在<span class="constant">OSX</span>下会有文件名大小写的问题
<span class="variable">$ </span>git pull 更新代码
<span class="variable">$ </span>git status  查看当前分支的状态，是否有冲突或未提交的文件
<span class="variable">$ </span>git log  查看当前分支的commit log，看看是否与远程分支一致
<span class="variable">$ </span>git add -<span class="constant">A</span>
<span class="variable">$ </span>git commit -m <span class="string">"xxx"</span>
<span class="variable">$ </span>git push origin vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span><span class="symbol">:vs-ezine-</span><span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span>
</pre></td></tr></table></figure>

<p>开发过程中文件撤销有几种方式：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>$ git reset HEAD &lt;file&gt;<span class="keyword">...</span>  保留本地修改，取消index
$ git checkout - &lt;file&gt;<span class="keyword">...</span>  放弃本地修改，将index移到working directory
$ git reset –hard &lt;commit-id&gt;  回退到某个commit-id，包括commit/index信息
$ git reset –soft &lt;commit-id&gt;  回退到某个commit-id，只是commit不包括index
</pre></td></tr></table></figure>

<p>开发结束后要把分支代码合并到master，并删除分支：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="variable">$ </span>git checkout master
<span class="variable">$ </span>git merge vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span>
<span class="variable">$ </span>git branch -<span class="constant">D</span> vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span> <span class="comment">#注意：这是是强制删除，但尽量不能删除当前分支，分支如果有commit未合并也不要删除</span>
<span class="variable">$ </span>git push origin <span class="symbol">:vs-ezine-</span><span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span> <span class="comment">#删除远程分支</span>
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>平时使用git依赖于IDE图形化界面插件，用起来倒没什么问题，但觉得还是有必要总结下常用的git命令，<a href="http://git-scm.com/book/zh" target="_blank" rel="external">点击查看Git中文文档</a>。</p>
<ol>
<li>一般我们clone已有的项目，默认就是git协议，URL后面可以指定目录：<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>liubaing/galaxy.git galaxy
</pre></td></tr></table></figure>

</li>
</ol>
<p>如果本地已经存在的项目</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git init
</pre></td></tr></table></figure>

<p>这时我们发现本地仓库有个隐藏目录.git，里面通常会有：</p>
<p>工作目录(working directory)我们实际持有的文件；<br>缓存区(index/stage)临时保存我们所做的修改；<br>HEAD指向我们最后一次提交的结果。</p>
<p>整个变化过程是这样的：working directory -&gt; “git add” -&gt; index -&gt; “git commit” -&gt; HEAD</p>
]]></summary>
    
      <category term="Git" scheme="http://liubaing.com/tags/Git/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linode退钱]]></title>
    <link href="http://liubaing.com/2014/04/12/Linode%E9%80%80%E9%92%B1/"/>
    <id>http://liubaing.com/2014/04/12/Linode退钱/</id>
    <published>2014-04-12T08:13:17.000Z</published>
    <updated>2016-11-10T08:36:22.000Z</updated>
    <content type="html"><![CDATA[<p>之前用过一段时间Linode，不过由于种种原因（其实就是懒）不想继续维护了，Remove掉主机后，它会自动结算剩余金额。也不想让钱那么寂寞的呆在账户里，琢磨怎么退还到信用卡里。<br><a id="more"></a></p>
<p>方法是登录Linode后给Linode客服发ticket申请退款。我直接写了一句 I don’t have time to maintain it and kindly need money，提交，等着收钱。然后客服回复后，退款自生成之日起，要3到5天才能到你的信用卡账户。</p>
<p>退款后，如果你觉得这个账户没有继续存在的必要，那么可以在account选项卡页面的最底部，找到“Cancel this Account”链接，点击即可。</p>
]]></content>
    <summary type="html"><![CDATA[<p>之前用过一段时间Linode，不过由于种种原因（其实就是懒）不想继续维护了，Remove掉主机后，它会自动结算剩余金额。也不想让钱那么寂寞的呆在账户里，琢磨怎么退还到信用卡里。<br>]]></summary>
    
      <category term="扯淡" scheme="http://liubaing.com/categories/%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
</feed>
