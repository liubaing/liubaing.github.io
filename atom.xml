<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[六八ing的博客]]></title>
  <subtitle><![CDATA[各种扯淡]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liubaing.com/"/>
  <updated>2015-07-27T10:29:26.773Z</updated>
  <id>http://liubaing.com/</id>
  
  <author>
    <name><![CDATA[何帅]]></name>
    <email><![CDATA[liubaing@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[排查Java进程CPU占有率高]]></title>
    <link href="http://liubaing.com/2015/07/27/%E6%8E%92%E6%9F%A5Java%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E6%9C%89%E7%8E%87%E9%AB%98/"/>
    <id>http://liubaing.com/2015/07/27/排查Java进程CPU占有率高/</id>
    <published>2015-07-27T08:35:56.000Z</published>
    <updated>2015-07-27T09:16:00.000Z</updated>
    <content type="html"><![CDATA[<p>最近尝试在项目中利用<code>com.sun.management.OperatingSystemMXBean</code>增加些调试信息，发现测试环境Java进程CPU占有率很高，Google后总结一些解决过程。</p>
<p>1.根据top命令，发现占有率高的Java的PID。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="preprocessor">#top</span>
</pre></td></tr></table></figure>


<p>2.找到该PID后，首先显示线程列表，并按照CPU占用高的线程排序。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">#ps</span> <span class="attribute">-mp</span> <span class="variable">$PID</span> <span class="attribute">-o</span> <span class="keyword">THREAD</span>,tid,time <span class="subst">|</span> sort <span class="attribute">-rn</span>
</pre></td></tr></table></figure>


<p>3.然后找到耗时最多的线程TID，将需要的TID转换为16进制格式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">#printf</span> <span class="comment">"%x\n"</span> <span class="char">$T</span>ID
</pre></td></tr></table></figure>


<p>4.打印线程的堆栈信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">#jstack</span> <span class="char">$P</span>ID |grep <span class="char">$0</span>xTID -<span class="class">A</span> <span class="number">30</span>
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="Linux" scheme="http://liubaing.com/tags/Linux/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL JDBC Driver版本Bug]]></title>
    <link href="http://liubaing.com/2015/07/21/MySQL-JDBC-Driver%E7%89%88%E6%9C%ACBug/"/>
    <id>http://liubaing.com/2015/07/21/MySQL-JDBC-Driver版本Bug/</id>
    <published>2015-07-21T09:12:15.000Z</published>
    <updated>2015-07-21T09:53:30.000Z</updated>
    <content type="html"><![CDATA[<p>上周发现线上的CTR信息不准确，影响到广告投放概率。</p>
<p>经过同事的排查发现是数据库实例连接错了，在jdbcUrl中指定的端口是是3307，但实际上是读写3306默认端口的数据库。</p>
<p>跟踪确定是Driver本身的Bug，Google了下官方已经有<a href="https://bugs.mysql.com/bug.php?id=47494" target="_blank" rel="external">相关Bug反馈</a>了，解决方案就是把mysql-connector-java的版本从5.1.9调整为5.1.18。</p>
]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[源码理解-Map]]></title>
    <link href="http://liubaing.com/2015/03/20/%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3-Map/"/>
    <id>http://liubaing.com/2015/03/20/源码理解-Map/</id>
    <published>2015-03-20T10:16:38.000Z</published>
    <updated>2015-07-27T08:33:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Map">Map</h3>
<h6 id="HashMap">HashMap</h6>
<p>首先要说得HashMap就是数组和链表得结合体，先看源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">/**
 * 默认初始化容量，必须是2的N次方
 */</span>
<span class="keyword">static</span> <span class="keyword">final</span> int DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span>
<span class="keyword">static</span> <span class="keyword">final</span> Entry<span class="preprocessor">&lt;?</span>,<span class="preprocessor">?&gt;</span>[] EMPTY_TABLE = {};
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; {</span>
    <span class="keyword">final</span> K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;
    ......
}
</pre></td></tr></table></figure>

<p>底层就是Entry数组，每个Entry持有next引用，构成链表。<br><a id="more"></a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">public</span> V <span class="title">put</span>(K key, V <span class="keyword">value</span>) {
    <span class="comment">//初次执行创建2的N次方容量的数组</span>
    <span class="keyword">if</span> (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    <span class="comment">//null键直接存在table[0]</span>
    <span class="keyword">if</span> (key == <span class="keyword">null</span>)
        <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);
    <span class="comment">//计算所在数组索引</span>
    <span class="keyword">int</span> hash = hash(key);
    <span class="keyword">int</span> i = indexFor(hash, table.length);
    <span class="comment">//链表头部开始迭代，如果key的hash值和引用同一个对象或者实现equals方法相等，直接替换value，并返回旧value</span>
    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) {
        Object k;
        <span class="keyword">if</span> (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.<span class="keyword">value</span>;
            e.<span class="keyword">value</span> = <span class="keyword">value</span>;
            <span class="comment">//LinkedHashMap维护链表顺序</span>
            e.recordAccess(<span class="keyword">this</span>);
            <span class="keyword">return</span> oldValue;
        }
    }
    <span class="comment">//更改次数，实现fast-fail</span>
    modCount++;
    addEntry(hash, key, <span class="keyword">value</span>, i);
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">void</span> addEntry(<span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex) {
    <span class="comment">//2倍扩容，如果在构造前明确容量需求，尽量指定避免扩容和重新映射</span>
    <span class="keyword">if</span> ((size &gt;= threshold) && (<span class="keyword">null</span> != table[bucketIndex])) {
        resize(<span class="number">2</span> * table.length);
        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, <span class="keyword">value</span>, bucketIndex);
}

<span class="keyword">void</span> createEntry(<span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, <span class="keyword">value</span>, e);
    size++;
}
</pre></td></tr></table></figure>

<p>当我们往HashMap中put元素的时候，计算key的hash值，根据hash值对数组长度取模运算得到在数组中的位置，如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。</p>
<p>前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">final</span> <span class="keyword">int</span> hash(Object k) {
    <span class="keyword">int</span> h = hashSeed;
    <span class="keyword">if</span> (<span class="number">0</span> != h && k <span class="keyword">instanceof</span> String) {
        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();
    <span class="comment">//减少碰撞</span>
    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);
    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);
}

<span class="keyword">static</span> <span class="keyword">int</span> indexFor(<span class="keyword">int</span> h, <span class="keyword">int</span> length) {
    <span class="comment">//注意这里没有采用%，而&实现有个前提length必须是2的N次方，</span>
    <span class="comment">//具体原因网上搜索下后得知 &操作用了3mov+1and+1sub，%操作用了2mov+1cdp+1idiv</span>
    <span class="comment">//前者只需5个CPU周期，而后者至少需要26个CPU周期</span>
    <span class="keyword">return</span> h & (length-<span class="number">1</span>);
}
</pre></td></tr></table></figure>

<p>那之前强调的保证length为2的N次方，原因就是为了充分利用数组空间，元素尽量散列些，具体就是而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1，这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<h6 id="ConcurrentHashMap">ConcurrentHashMap</h6>
]]></content>
    <summary type="html"><![CDATA[<h3 id="Map">Map</h3>
<h6 id="HashMap">HashMap</h6>
<p>首先要说得HashMap就是数组和链表得结合体，先看源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">/**
 * 默认初始化容量，必须是2的N次方
 */</span>
<span class="keyword">static</span> <span class="keyword">final</span> int DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span>
<span class="keyword">static</span> <span class="keyword">final</span> Entry<span class="preprocessor">&lt;?</span>,<span class="preprocessor">?&gt;</span>[] EMPTY_TABLE = {};
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; {</span>
    <span class="keyword">final</span> K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;
    ......
}
</pre></td></tr></table></figure>

<p>底层就是Entry数组，每个Entry持有next引用，构成链表。<br>]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[源码理解-Collection]]></title>
    <link href="http://liubaing.com/2015/03/17/%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3-Collection/"/>
    <id>http://liubaing.com/2015/03/17/源码理解-Collection/</id>
    <published>2015-03-17T05:44:23.000Z</published>
    <updated>2015-07-27T08:24:29.000Z</updated>
    <content type="html"><![CDATA[<p>JDK中提供的集合类一般不外乎就两种数据结构，数组和引用(链表)。<br>下面简单总结下常用的集合类。</p>
<h3 id="Collection">Collection</h3>
<h4 id="List">List</h4>
<h6 id="ArrayList">ArrayList</h6>
<p>数组</p>
<h6 id="LinkedList">LinkedList</h6>
<p>双向链表</p>
<h4 id="Set">Set</h4>
<p>value为new Object()</p>
<h6 id="HashSet">HashSet</h6>
<h6 id="TreeSet">TreeSet</h6>
<h4 id="Queue">Queue</h4>
<h6 id="ArrayBlockingQueue">ArrayBlockingQueue</h6>
<h5 id="Deque">Deque</h5>
<h6 id="LinkedBlockingDeque">LinkedBlockingDeque</h6>
]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web下文件下载]]></title>
    <link href="http://liubaing.com/2014/12/10/Web%E4%B8%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <id>http://liubaing.com/2014/12/10/Web下文件下载/</id>
    <published>2014-12-10T02:45:20.000Z</published>
    <updated>2014-12-10T11:19:16.000Z</updated>
    <content type="html"><![CDATA[<p>下载中文名文件，这个场景在很多Web下经常遇到。</p>
<p>普遍思路，保存文件重命名，记录下原文件名，待用户下载时，response header种设置下原文件名。</p>
<p>需要注意的是，考虑到浏览器兼容问题，文件名不仅要URLEncode编码处理，还需要遵循<a href="http://tools.ietf.org/html/rfc2231" target="_blank" rel="external">RFC 2231</a>，参数Key后增加星号，Value前面为字符集和单引号中的语言，比如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Content-disposition: attachment;filename<span class="variable">*=</span>utf-<span class="number">8</span><span class="string">'zh_cn'</span><span class="variable">%e4</span><span class="variable">%b8</span><span class="variable">%ad</span><span class="variable">%e6</span><span class="variable">%96</span><span class="variable">%87</span>.pdf
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的单例模式]]></title>
    <link href="http://liubaing.com/2014/10/19/Java%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liubaing.com/2014/10/19/Java中的单例模式/</id>
    <published>2014-10-19T10:28:54.000Z</published>
    <updated>2014-10-19T14:39:16.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式是Java设计模式中相当经典的了，平时工作接触的也只有懒汉、饿汉之类的，之前阿里面试中也被问到这个问题，今天就总结一下。</p>
<h4 id="饿汉式">饿汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>一般不希望在类加载时就创建对象，改进后：</p>
<h4 id="简单实现线程安全的懒汉式">简单实现线程安全的懒汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> synchronized Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>上面例子的性能不太理想，其实只需第一次调用时同步，利用JDK1.5中volatile关键字改进后：<br><a id="more"></a></p>
<p><h4>利用volatile的懒汉式</h4></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            synchronized (Singleton.class) {
                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
                    instance = <span class="keyword">new</span> Singleton();
                }
            }
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<h4 id="利用枚举类">利用枚举类</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> Singleton {
    INSTANCE;
}
</pre></td></tr></table></figure>

<h4 id="利用内部类机制实现">利用内部类机制实现</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {

    <span class="keyword">private</span> <span class="title">Singleton</span>() { }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> SingletonHolder {
        <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> SingletonHolder.INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>总结下，尽管上面列举一些方法实现单例，但还是不完全能保证，还需要注意反序列化和反射。个人推荐枚举方式，代码量简介而且很好利用JVM。</p>
]]></content>
    <summary type="html"><![CDATA[<p>单例模式是Java设计模式中相当经典的了，平时工作接触的也只有懒汉、饿汉之类的，之前阿里面试中也被问到这个问题，今天就总结一下。</p>
<h4 id="饿汉式">饿汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>一般不希望在类加载时就创建对象，改进后：</p>
<h4 id="简单实现线程安全的懒汉式">简单实现线程安全的懒汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> synchronized Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>上面例子的性能不太理想，其实只需第一次调用时同步，利用JDK1.5中volatile关键字改进后：<br>]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中常用的时间格式化注意点]]></title>
    <link href="http://liubaing.com/2014/09/18/Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://liubaing.com/2014/09/18/Java中常用的时间格式化注意点/</id>
    <published>2014-09-18T09:29:24.000Z</published>
    <updated>2015-07-27T08:41:57.000Z</updated>
    <content type="html"><![CDATA[<p>平时工作中或多或少都会遇到时间格式化的问题，传统思路都利用<code>java.text.SimpleDateFormat</code>，然后根据业务场景写几个Pattern去处理。</p>
<p>之前接触到项目中一般都会提供一个工具类，既然是工具类，那就按套路了，上面声明几个不同格式的Pattern实例，下面写几个static方法，然后处理下异常之类的。</p>
<p>这样的好处是避免方法调用时去new SimpleDateFormat，从而创建大量的实例对象，毕竟SimpleDateFormat类初始化代价不小，父类DateFormat中成员变量包含Calendar等。</p>
<p>但恰恰就因为这个成员变量，并且format方法又没有同步，所以这个工具类在多线程下风险很高。</p>
<p>这个问题在网上也看到很多解决方案，参考JDK中注释。</p>
<blockquote>
<p> Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally</p>
</blockquote>
<h4 id="同步SimpleDateFormat对象">同步SimpleDateFormat对象</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) <span class="keyword">throws</span> ParseException {
    <span class="keyword">synchronized</span>(sdf) {
        <span class="keyword">return</span> sdf.format(date);
    }
}
</pre></td></tr></table></figure><br>同步随之而来就是阻塞</p>
<h4 id="使用ThreadLocal">使用ThreadLocal</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> final String FULL_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;
<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();

<span class="keyword">public</span> <span class="keyword">static</span> SimpleDateFormat <span class="title">getDateFormat</span>() {
    SimpleDateFormat dateFormat = threadLocal.<span class="keyword">get</span>();
    <span class="keyword">if</span> (dateFormat == <span class="keyword">null</span>) {
        dateFormat = <span class="keyword">new</span> SimpleDateFormat(FULL_DATE_FORMAT);
        threadLocal.<span class="keyword">set</span>(dateFormat);
    }
    <span class="keyword">return</span> dateFormat;
}

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) throws ParseException {
    <span class="keyword">return</span> getDateFormat().format(date);
}
</pre></td></tr></table></figure><br>共享变量变成了线程私有</p>
<a id="more"></a>

<h4 id="使用Joda-Time类库">使用Joda-Time类库</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FULL_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(DateTime dateTime) {
    <span class="keyword">return</span> dateTime.toString(FULL_DATE_FORMAT);
}
</pre></td></tr></table></figure><br>对用户自定义Pattern，Joda在解析并创建<code>org.joda.time.format.DateTimeFormatter</code>会Cache，不用过于担心性能问题，当然也自己手动去Cache，因为DateTime有多个toString()重载方法。</p>
]]></content>
    <summary type="html"><![CDATA[<p>平时工作中或多或少都会遇到时间格式化的问题，传统思路都利用<code>java.text.SimpleDateFormat</code>，然后根据业务场景写几个Pattern去处理。</p>
<p>之前接触到项目中一般都会提供一个工具类，既然是工具类，那就按套路了，上面声明几个不同格式的Pattern实例，下面写几个static方法，然后处理下异常之类的。</p>
<p>这样的好处是避免方法调用时去new SimpleDateFormat，从而创建大量的实例对象，毕竟SimpleDateFormat类初始化代价不小，父类DateFormat中成员变量包含Calendar等。</p>
<p>但恰恰就因为这个成员变量，并且format方法又没有同步，所以这个工具类在多线程下风险很高。</p>
<p>这个问题在网上也看到很多解决方案，参考JDK中注释。</p>
<blockquote>
<p> Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally</p>
</blockquote>
<h4 id="同步SimpleDateFormat对象">同步SimpleDateFormat对象</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) <span class="keyword">throws</span> ParseException {
    <span class="keyword">synchronized</span>(sdf) {
        <span class="keyword">return</span> sdf.format(date);
    }
}
</pre></td></tr></table></figure><br>同步随之而来就是阻塞</p>
<h4 id="使用ThreadLocal">使用ThreadLocal</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> final String FULL_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;
<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();

<span class="keyword">public</span> <span class="keyword">static</span> SimpleDateFormat <span class="title">getDateFormat</span>() {
    SimpleDateFormat dateFormat = threadLocal.<span class="keyword">get</span>();
    <span class="keyword">if</span> (dateFormat == <span class="keyword">null</span>) {
        dateFormat = <span class="keyword">new</span> SimpleDateFormat(FULL_DATE_FORMAT);
        threadLocal.<span class="keyword">set</span>(dateFormat);
    }
    <span class="keyword">return</span> dateFormat;
}

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) throws ParseException {
    <span class="keyword">return</span> getDateFormat().format(date);
}
</pre></td></tr></table></figure><br>共享变量变成了线程私有</p>
]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用浏览器下调试]]></title>
    <link href="http://liubaing.com/2014/07/26/%E5%B8%B8%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%B0%83%E8%AF%95/"/>
    <id>http://liubaing.com/2014/07/26/常用浏览器下调试/</id>
    <published>2014-07-26T07:41:31.000Z</published>
    <updated>2015-07-27T08:39:12.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Safari</strong>下显示开发者调试工具方法:<br>Preferences - Advanced - Show Develop menu in menu bar</p>
<p><strong>Firefox</strong>本身包含开发者工具，当然Firebug插件大家更常用。</p>
<p><strong>Chrome</strong>下默认的Inspect Element(以下测试均在Chrome Version 36.0.1985.125下)</p>
<h2 id="Console">Console</h2>
<p>使用alert调试在迭代输出时很不方便，这时利用log可以很直观的观察运行状态。</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&gt; console.<span class="keyword">log</span>(<span class="string">'hello world'</span>);
  hello world
&gt; console.<span class="keyword">warn</span>(<span class="string">'warning info'</span>);
&gt; console.<span class="keyword">warn</span>(<span class="string">'error message'</span>)
</pre></td></tr></table></figure><br>平时在Sources标签下对JS方法设置断点Debug时，可以查看作用域内的变量，也可以利用在Console中直接输入变量名查看。</p>
<a id="more"></a>

<h2 id="Emulation">Emulation</h2>
<p>用来调试移动网站的利器，可以模拟移动设备分辨率，UA等，还可以模拟传感器，比如经纬度。</p>
<h2 id="Network">Network</h2>
<p>在这里罗列了当前页所有的HTTP请求，注意Status和Timeline用来作为优化请求的参考标准。<br>点击每条请求能看到请求头、请求参数、响应头、响应内容等信息，比如AJAX请求中比较关注的Content-Type字段。</p>
<h2 id="Resources">Resources</h2>
<p>一般常用就是Cookies标签，可以手动清除部分Cookie。<br>现在很多站点也开始采用H5中的Storage，在这里也可以查看并手动编辑。</p>
<h2 id="Elements">Elements</h2>
<p>查看页面节点信息，可以手动调整DOM，也可以更改CSS，观察渲染样式，查看节点监听事件。</p>
]]></content>
    <summary type="html"><![CDATA[<p><strong>Safari</strong>下显示开发者调试工具方法:<br>Preferences - Advanced - Show Develop menu in menu bar</p>
<p><strong>Firefox</strong>本身包含开发者工具，当然Firebug插件大家更常用。</p>
<p><strong>Chrome</strong>下默认的Inspect Element(以下测试均在Chrome Version 36.0.1985.125下)</p>
<h2 id="Console">Console</h2>
<p>使用alert调试在迭代输出时很不方便，这时利用log可以很直观的观察运行状态。</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&gt; console.<span class="keyword">log</span>(<span class="string">'hello world'</span>);
  hello world
&gt; console.<span class="keyword">warn</span>(<span class="string">'warning info'</span>);
&gt; console.<span class="keyword">warn</span>(<span class="string">'error message'</span>)
</pre></td></tr></table></figure><br>平时在Sources标签下对JS方法设置断点Debug时，可以查看作用域内的变量，也可以利用在Console中直接输入变量名查看。</p>
]]></summary>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP常见乱码问题]]></title>
    <link href="http://liubaing.com/2014/06/27/HTTP%E5%B8%B8%E8%A7%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://liubaing.com/2014/06/27/HTTP常见乱码问题/</id>
    <published>2014-06-27T07:42:03.000Z</published>
    <updated>2015-07-20T07:41:22.000Z</updated>
    <content type="html"><![CDATA[<p>众所周知，乱码问题源于编码不一致，往往在平时开发中容易忽略指明编码，而依赖于默认编码。</p>
<p>比如使用Spring MVC时需要配置org.springframework.http.converter.StringHttpMessageConverter的defaultCharset；<br>还有使用HttpClient时注意响应中ByteArray反序列化时也要指明charsetName，否则读取JVM参数file.encoding。</p>
<p>总结下就是一般输入输出流尽量指明编码，防止出现环境不一样导致乱码问题。</p>
]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[龙泉驾校约车脚本]]></title>
    <link href="http://liubaing.com/2014/06/18/%E9%BE%99%E6%B3%89%E9%A9%BE%E6%A0%A1%E7%BA%A6%E8%BD%A6%E8%84%9A%E6%9C%AC/"/>
    <id>http://liubaing.com/2014/06/18/龙泉驾校约车脚本/</id>
    <published>2014-06-18T08:20:49.000Z</published>
    <updated>2014-09-19T03:08:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近该学科目二，可一连几天都约不上车，开始琢磨写个脚本，看有没有效果。<br><a id="more"></a></p>
<p>抱怨驾校也是徒劳，谁让当时图便宜呢。脚本也是参考了其他同学的代码，调整后不是特别完善，不过龙泉的校友还是可以参考。</p>
<p>下面是执行脚本，其中有些参数根据自己情况填写：</p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="comment"># !/usr/bin/python</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> lqjx
<span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

logging.basicConfig(level=logging.DEBUG,
                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,
                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>)

<span class="comment">#约车时段，全部、上午8-12、下午1-5、晚上5-8</span>
xnsd = (<span class="string">"-1"</span>, <span class="string">"812"</span>, <span class="string">"15"</span>, <span class="string">"58"</span>)
<span class="comment">#指定想约的教练</span>
jlcbh = <span class="string">""</span>
uname = <span class="string">""</span>
passwd = <span class="string">""</span>

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    lq = lqjx.LQJX()
    <span class="keyword">try</span>:
        <span class="keyword">if</span> lq.login(uname, passwd):
            <span class="keyword">while</span> <span class="number">1</span>:
                cars = lq.get_bookable_car(xnsd[<span class="number">1</span>])
                <span class="keyword">if</span> <span class="string">'null_0'</span> <span class="keyword">in</span> cars:
                    logging.info(<span class="string">'没到时间或者没有可预订车辆！'</span>)
                <span class="keyword">else</span>:
                    result = lq.order_car(xnsd[<span class="number">1</span>], jlcbh)
                    <span class="keyword">print</span> result
                    <span class="keyword">if</span> <span class="string">u'成功'</span> <span class="keyword">in</span> result:
                        logging.info(<span class="string">'\n 预定成功！'</span>)
                        sys.exit(<span class="number">0</span>)
                <span class="comment">#增加间隔时间，防止频繁请求，账号被封</span>
                time.sleep(<span class="number">30</span>)
    <span class="keyword">except</span> KeyboardInterrupt:
        lq.logout()
        logging.info(<span class="string">'退出约车系统！'</span>)
</pre></td></tr></table></figure>

<p>下面是核心模块：</p>
<p><a id="more"></a></p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="code"><pre><span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> requests
<span class="keyword">import</span> datetime
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

LQJX_HOST = <span class="string">"http://106.37.230.254:81"</span>
lq_session = requests.Session()


<span class="class"><span class="keyword">class</span> <span class="title">LQJX</span>:</span>

    header = {
        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36'</span>
    }

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        <span class="keyword">pass</span>

    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self, uname, passwd)</span>:</span>
        post_data = {
            <span class="string">'__VIEWSTATE'</span>: <span class="string">'/wEPDwUKMTg0NDI4MDE5OGRkj8OrkkOlfYqdhxkeEVV4GsZ6FLw0IioIcl+nbwqoGbo='</span>,
            <span class="string">'__EVENTVALIDATION'</span>: <span class="string">'/wEWBgKF6pivDAKl1bKzCQK1qbSRCwLoyMm8DwLi44eGDAKAv7D9Co04a1vpmJ/QuWDi2GFypJ8LBXRdxHsgxKaj/eIzgMJ6'</span>,
            <span class="string">'txtUserName'</span>: uname,
            <span class="string">'txtPassword'</span>: passwd,
            <span class="string">'BtnLogin'</span>: <span class="string">'登  录'</span>,
            <span class="string">'rcode'</span>: <span class="string">''</span>
        }
        result = lq_session.post(LQJX_HOST + <span class="string">'/login.aspx'</span>, data=post_data, headers=self.header)
        <span class="keyword">if</span> <span class="string">'zhxx.aspx'</span> <span class="keyword">in</span> result.text:
            logging.info(<span class="string">"登录成功!"</span>)
            flag = <span class="keyword">True</span>
        <span class="keyword">else</span>:
            logging.error(<span class="string">"登录失败，请检查账号状态或请求参数!"</span>)
            flag = <span class="keyword">False</span>
        <span class="keyword">return</span> flag

    <span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">(self)</span>:</span>
        lq_session.get(LQJX_HOST + <span class="string">'/Login.aspx?LoginOut=true'</span>, headers=self.header)

    <span class="function"><span class="keyword">def</span> <span class="title">order_car</span><span class="params">(self, xnsd, jlcbh)</span>:</span>
        query_param = {
            <span class="string">'jlcbh'</span>: jlcbh,  <span class="comment">#教练场编号</span>
            <span class="string">'yyrqbegin'</span>: str(datetime.date.today() + datetime.timedelta(<span class="number">13</span>)).replace(<span class="string">'-'</span>, <span class="string">''</span>),  <span class="comment">#预约14天后</span>
            <span class="string">'xnsd'</span>: xnsd,  <span class="comment">#时段 -1  812  15  58</span>
            <span class="string">'trainType'</span>: <span class="string">'3'</span>,  <span class="comment">#原地1 道路3 实际4</span>
            <span class="string">'type'</span>: <span class="string">'km2Car2'</span>,  <span class="comment">#约车类型 科目二km2Car2</span>
            <span class="string">'_'</span>: int(time.time())  <span class="comment">#时间戳</span>
        }
        <span class="keyword">return</span> lq_session.get(LQJX_HOST + <span class="string">"/Tools/km2.aspx?"</span>, params=query_param, headers=self.header).text

    <span class="function"><span class="keyword">def</span> <span class="title">get_bookable_car</span><span class="params">(self, xnsd)</span>:</span>
        base_url = LQJX_HOST + <span class="string">"/Tools/km2.aspx?date="</span> + str(datetime.datetime.now())
        query_param = {
            <span class="string">'filters[yyrq]'</span>: str(datetime.date.today() + datetime.timedelta(<span class="number">13</span>)).replace(<span class="string">'-'</span>, <span class="string">''</span>),
            <span class="string">'filters[xnsd]'</span>: xnsd,
            <span class="string">'filters[xllxid]'</span>: <span class="string">'3'</span>,
            <span class="string">'filters[type]'</span>: <span class="string">'km2Car'</span>,
            <span class="string">'filters[cnbh]'</span>: <span class="string">''</span>, <span class="comment">#场内编号，不填写则为全部</span>
            <span class="string">'pageno'</span>: <span class="string">'1'</span>,
            <span class="string">'pagesize'</span>: <span class="string">'30'</span>,
            <span class="string">'_'</span>: int(time.time())
        }
        <span class="keyword">return</span> lq_session.get(base_url, params=query_param).text

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="keyword">pass</span>
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>最近该学科目二，可一连几天都约不上车，开始琢磨写个脚本，看有没有效果。<br><!--more--></p>
<p>抱怨驾校也是徒劳，谁让当时图便宜呢。脚本也是参考了其他同学的代码，调整后不是特别完善，不过龙泉的校友还是可以参考。</p>
<p>下面是执行脚本，其中有些参数根据自己情况填写：</p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="comment"># !/usr/bin/python</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> lqjx
<span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

logging.basicConfig(level=logging.DEBUG,
                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,
                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>)

<span class="comment">#约车时段，全部、上午8-12、下午1-5、晚上5-8</span>
xnsd = (<span class="string">"-1"</span>, <span class="string">"812"</span>, <span class="string">"15"</span>, <span class="string">"58"</span>)
<span class="comment">#指定想约的教练</span>
jlcbh = <span class="string">""</span>
uname = <span class="string">""</span>
passwd = <span class="string">""</span>

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    lq = lqjx.LQJX()
    <span class="keyword">try</span>:
        <span class="keyword">if</span> lq.login(uname, passwd):
            <span class="keyword">while</span> <span class="number">1</span>:
                cars = lq.get_bookable_car(xnsd[<span class="number">1</span>])
                <span class="keyword">if</span> <span class="string">'null_0'</span> <span class="keyword">in</span> cars:
                    logging.info(<span class="string">'没到时间或者没有可预订车辆！'</span>)
                <span class="keyword">else</span>:
                    result = lq.order_car(xnsd[<span class="number">1</span>], jlcbh)
                    <span class="keyword">print</span> result
                    <span class="keyword">if</span> <span class="string">u'成功'</span> <span class="keyword">in</span> result:
                        logging.info(<span class="string">'\n 预定成功！'</span>)
                        sys.exit(<span class="number">0</span>)
                <span class="comment">#增加间隔时间，防止频繁请求，账号被封</span>
                time.sleep(<span class="number">30</span>)
    <span class="keyword">except</span> KeyboardInterrupt:
        lq.logout()
        logging.info(<span class="string">'退出约车系统！'</span>)
</pre></td></tr></table></figure>

<p>下面是核心模块：</p>
<p>]]></summary>
    
      <category term="Python" scheme="http://liubaing.com/tags/Python/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[世界杯直播]]></title>
    <link href="http://liubaing.com/2014/06/15/%E4%B8%96%E7%95%8C%E6%9D%AF%E7%9B%B4%E6%92%AD/"/>
    <id>http://liubaing.com/2014/06/15/世界杯直播/</id>
    <published>2014-06-15T03:10:39.000Z</published>
    <updated>2014-07-03T03:20:07.000Z</updated>
    <content type="html"><![CDATA[<p>感谢世界杯给我们带来如此精彩的比赛，感谢CCTV节目组和解说嘉宾，更要感谢我们身边那个支持我们熬夜看球的人，但不用谢我，我只是搬运工。<br><a id="more"></a></p>
<iframe height="408" width="510" src="http://static.youku.com/v1.0.0550/v/swf/livePlayer.swf?autoplay=1&showlogo=0&channel=204" frameborder="0" allowfullscreen></iframe>

<p>今天是父亲节，在此借助世界杯祝愿天下所有父亲身体健康，感谢生命中有您的陪伴！</p>
]]></content>
    <summary type="html"><![CDATA[<p>感谢世界杯给我们带来如此精彩的比赛，感谢CCTV节目组和解说嘉宾，更要感谢我们身边那个支持我们熬夜看球的人，但不用谢我，我只是搬运工。<br>]]></summary>
    
      <category term="生活" scheme="http://liubaing.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[翻墙]]></title>
    <link href="http://liubaing.com/2014/06/13/%E7%BF%BB%E5%A2%99/"/>
    <id>http://liubaing.com/2014/06/13/翻墙/</id>
    <published>2014-06-13T08:38:14.000Z</published>
    <updated>2014-07-18T07:11:57.000Z</updated>
    <content type="html"><![CDATA[<p>最近Google访问不了，各种403和连接被重置。<br><a id="more"></a><br>这给平时工作带来很大的不便，至于原因大家心知肚明。</p>
<p>之前由于改过hosts，遇到Google被墙对自己影响不大，但这次彻底歇菜了。</p>
<p>选择VPN还得取决所在网络环境，L2TP方式经常连接不上，所以暂时先Pass。看微博上有推荐用SSH代理，去淘宝上搜了一家，10块一月，感觉价格可以接受，还是香港主机，下单吧。</p>
<p>跟大家分享Mac下的方法，首先打开终端输入</p>
<p><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ssh <span class="attribute">-qTfnNv</span> <span class="attribute">-D</span> <span class="number">7070</span> username@host
</pre></td></tr></table></figure><br>输入密码后在网络设置中增加代理，这里选择SOCKS Proxy，输入127.0.0.1:7070后点击应用。</p>
<p><img src="http://liubaing.qiniudn.com/ssh_proxy.jpeg" alt="增加代理"></p>
<p>现在，打开浏览器试试吧！</p>
<hr>
<p>2014-6-19更新：</p>
<p>提供新版<a href="http://liubaing.qiniudn.com/hosts" target="_blank" rel="external">hosts</a>下载，大家自测。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近Google访问不了，各种403和连接被重置。<br>]]></summary>
    
      <category term="hosts" scheme="http://liubaing.com/tags/hosts/"/>
    
      <category term="VPN" scheme="http://liubaing.com/tags/VPN/"/>
    
      <category term="Google" scheme="http://liubaing.com/tags/Google/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git日常操作]]></title>
    <link href="http://liubaing.com/2014/05/02/Git%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/"/>
    <id>http://liubaing.com/2014/05/02/Git日常操作/</id>
    <published>2014-05-02T07:05:24.000Z</published>
    <updated>2015-07-21T10:10:28.000Z</updated>
    <content type="html"><![CDATA[<p>平时使用git依赖于IDE图形化界面插件，用起来倒没什么问题，但觉得还是有必要总结下常用的git命令，<a href="http://git-scm.com/book/zh" target="_blank" rel="external">点击查看Git中文文档</a>。</p>
<p>一般我们clone已有的项目，默认就是git协议，URL后面可以指定目录：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>liubaing/galaxy.git galaxy
</pre></td></tr></table></figure>

<p>本地默认会创建一个master分支，拿平时开发项目为例，我们还需要建立MS分支：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>$ git checkout <span class="attribute">-b</span> vs<span class="attribute">-ezine</span><span class="subst">-</span><span class="number">4.2</span><span class="number">.0</span><span class="attribute">-MS20140702</span> <span class="variable">#branch</span>为要切换的目的分支
Switched <span class="keyword">to</span> a <span class="literal">new</span> branch <span class="string">'vs-ezine-4.2.0-MS20140702'</span>
</pre></td></tr></table></figure><br><a id="more"></a><br><br><br>现在我们来看下本地分支:<br><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$ git branch <span class="attribute">-a</span> 查看所有分支
  master
<span class="subst">*</span> vs<span class="attribute">-ezine</span><span class="subst">-</span><span class="number">4.2</span><span class="number">.0</span><span class="attribute">-MS20140702</span>
</pre></td></tr></table></figure>

<p>开发过程中需要提交时：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="variable">$ </span>git pull <span class="comment">#更新代码</span>
<span class="variable">$ </span>git status  <span class="comment">#查看当前分支的状态，是否有冲突或未提交的文件</span>
<span class="variable">$ </span>git log  <span class="comment">#查看当前分支的commit log，看看是否与远程分支一致</span>
<span class="variable">$ </span>git add -<span class="constant">A</span>
<span class="variable">$ </span>git commit -m <span class="string">"xxx"</span>
<span class="variable">$ </span>git push origin vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span><span class="symbol">:vs-ezine-</span><span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span>
</pre></td></tr></table></figure>

<p>开发过程中文件revert有两种方式：<br>用<code>git reset HEAD &lt;file&gt;...</code>来取消暂存文件，<br>用<code>git checkout -- &lt;file&gt;...</code>来取消文件修改。</p>
<p>开发结束后要把分支代码合并到master，并删除分支：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="variable">$ </span>git checkout master
<span class="variable">$ </span>git merge vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span>
<span class="variable">$ </span>git branch -<span class="constant">D</span> vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span> <span class="comment">#注意：这是是强制删除，但尽量不能删除当前分支，分支如果有commit未合并也不要删除</span>
<span class="variable">$ </span>git push origin <span class="symbol">:vs-ezine-</span><span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span> <span class="comment">#删除远程分支</span>
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>平时使用git依赖于IDE图形化界面插件，用起来倒没什么问题，但觉得还是有必要总结下常用的git命令，<a href="http://git-scm.com/book/zh" target="_blank" rel="external">点击查看Git中文文档</a>。</p>
<p>一般我们clone已有的项目，默认就是git协议，URL后面可以指定目录：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>liubaing/galaxy.git galaxy
</pre></td></tr></table></figure>

<p>本地默认会创建一个master分支，拿平时开发项目为例，我们还需要建立MS分支：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>$ git checkout <span class="attribute">-b</span> vs<span class="attribute">-ezine</span><span class="subst">-</span><span class="number">4.2</span><span class="number">.0</span><span class="attribute">-MS20140702</span> <span class="variable">#branch</span>为要切换的目的分支
Switched <span class="keyword">to</span> a <span class="literal">new</span> branch <span class="string">'vs-ezine-4.2.0-MS20140702'</span>
</pre></td></tr></table></figure><br>]]></summary>
    
      <category term="Git" scheme="http://liubaing.com/tags/Git/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linode退钱]]></title>
    <link href="http://liubaing.com/2014/04/12/Linode%E9%80%80%E9%92%B1/"/>
    <id>http://liubaing.com/2014/04/12/Linode退钱/</id>
    <published>2014-04-12T08:13:17.000Z</published>
    <updated>2015-07-27T08:39:12.000Z</updated>
    <content type="html"><![CDATA[<p>之前用过一段时间Linode，不过由于种种原因（其实就是懒）不想继续维护了，Remove掉主机后，它会自动结算剩余金额。也不想让钱那么寂寞的呆在账户里，琢磨怎么退还到信用卡里。<br><a id="more"></a></p>
<p>方法是登录Linode后给Linode客服发ticket申请退款。我直接写了一句 I don’t have time to maintain it and kindly need money，提交，等着收钱。然后客服回复后，退款自生成之日起，要3到5天才能到你的信用卡账户。</p>
<p>退款后，如果你觉得这个账户没有继续存在的必要，那么可以在account选项卡页面的最底部，找到“Cancel this Account”链接，点击即可。</p>
]]></content>
    <summary type="html"><![CDATA[<p>之前用过一段时间Linode，不过由于种种原因（其实就是懒）不想继续维护了，Remove掉主机后，它会自动结算剩余金额。也不想让钱那么寂寞的呆在账户里，琢磨怎么退还到信用卡里。<br>]]></summary>
    
      <category term="Linode" scheme="http://liubaing.com/tags/Linode/"/>
    
      <category term="扯淡" scheme="http://liubaing.com/categories/%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim基本操作]]></title>
    <link href="http://liubaing.com/2014/03/03/Vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://liubaing.com/2014/03/03/Vim基本操作/</id>
    <published>2014-03-03T03:16:05.000Z</published>
    <updated>2015-07-27T08:39:12.000Z</updated>
    <content type="html"><![CDATA[<p>废话不多说，直入主题吧。</p>
<h4 id="1、平时常用操作">1、平时常用操作</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>vim 启动vim
i 进入插入模式
&lt;<span class="constant">Esc</span>&gt; 回到编辑模式
<span class="symbol">:w</span> filename （保存文件为<span class="string">"filename"</span>）
<span class="symbol">:q</span> 退出vim
</pre></td></tr></table></figure>

<h4 id="2、删除">2、删除</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="tag">vim</span> <span class="tag">filename</span>
<span class="pseudo">:set</span> <span class="tag">nu</span> 显示行号
<span class="pseudo">:n</span> 移动到第<span class="tag">n</span>行
<span class="pseudo">:1</span>,5<span class="tag">d</span> 回车后，删除1<span class="tag">-5</span>行
<span class="pseudo">:u</span> 恢复
<span class="pseudo">:dG</span> 删除所有行
<span class="pseudo">:dd</span> 剪切光标所在整行
<span class="pseudo">:dw</span> 删除该单词
<span class="pseudo">:d0</span> 删除该行开始到当前光标
</pre></td></tr></table></figure>

<h4 id="3、移动光标">3、移动光标</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>/kw 向前搜索kw
?kw 向后搜索kw
<span class="number">0</span> 跳到行首
<span class="variable">$ </span>跳到行尾
gg 跳到首行
<span class="constant">G</span> 跳到文件末尾
</pre></td></tr></table></figure>

<h4 id="4、批量加注释">4、批量加注释</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>编辑模式下，按下Ctrl + v，进入列（也叫区块）模式
使用上下键（shift可翻页）选择需要注释的多行
按下键盘（大写）<span class="keyword">I</span>键，进入插入模式
然后输入注释符
最后按下esc键才会出现注释
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="Vim" scheme="http://liubaing.com/tags/Vim/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://liubaing.com/2014/02/08/hello-world/"/>
    <id>http://liubaing.com/2014/02/08/hello-world/</id>
    <published>2014-02-07T23:56:29.000Z</published>
    <updated>2015-07-17T10:24:28.000Z</updated>
    <content type="html"><![CDATA[<p>迁移到Github上，发现很多好玩的东西，比如现在用的Hexo，在写博客同时也能多了解些NodeJS。<br><a id="more"></a><br>之前零零散散也分享过，但都没坚持多久就荒废了，然后在微博上偶尔也会唠叨几句自己遇到的问题，最近想着自己能把博客坚持写下去，多少也是对码农生涯一个见证。</p>
]]></content>
    <summary type="html"><![CDATA[<p>迁移到Github上，发现很多好玩的东西，比如现在用的Hexo，在写博客同时也能多了解些NodeJS。<br>]]></summary>
    
      <category term="扯淡" scheme="http://liubaing.com/categories/%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
</feed>
