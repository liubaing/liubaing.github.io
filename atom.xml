<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[六八ing的博客]]></title>
  <subtitle><![CDATA[各种扯淡]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liubaing.com/"/>
  <updated>2017-03-02T11:45:26.240Z</updated>
  <id>http://liubaing.com/</id>
  
  <author>
    <name><![CDATA[何帅]]></name>
    <email><![CDATA[liubaing@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Protocol Buffers 3]]></title>
    <link href="http://liubaing.com/2017/02/23/Protocol-Buffers-3/"/>
    <id>http://liubaing.com/2017/02/23/Protocol-Buffers-3/</id>
    <published>2017-02-23T10:04:02.000Z</published>
    <updated>2017-03-01T08:54:11.000Z</updated>
    <content type="html"><![CDATA[<p>由于接口同时支持<code>application/x-protobuf</code>和<code>application/json</code>两种<code>content-type</code>，所以<code>protobuf-java</code>提供的JSON序列化方案性能也是我们比较关注的。</p>
<p>最近注意到<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="external">Protocol Buffers 3</a>（下称proto3）中对JSON的处理调整为利用Gson实现，尝试升级到proto3，这里简单总结下中间遇到的一些问题。</p>
<h4 id="proto3语法规则">proto3语法规则</h4>
<ul>
<li><p>描述文件头部增加语法声明<code>syntax = &quot;proto3&quot;</code> ，这样<code>protoc</code>会正确编译生成代码。</p>
</li>
<li><p>移除<code>required</code>描述关键字，字段默认是<code>optional</code>。</p>
</li>
<li><p>移除<code>default</code>选项，proto2可以使用<code>default</code>为某一字段指定默认值，但proto3字段的默认值只能根据字段类型由系统决定。</p>
</li>
<li><p>enum类型第一个字段的字段编号tags必须为0。</p>
</li>
<li><p>添加新的字段选项<code>json_name</code>。默认在proto3的JSON格式中字段名将被转换为<code>lowerCamelCase</code>，这个选项被用于自定义字段名。</p>
</li>
</ul>
<a id="more"></a>

<h4 id="JsonFormat注意点"><code>JsonFormat</code>注意点</h4>
<h5 id="反序列化">反序列化</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>HttpInputMessage inputMessage<span class="comment">;</span>
InputStreamReader reader<span class="comment">;</span>
if (MediaType<span class="preprocessor">.APPLICATION</span>_JSON<span class="preprocessor">.isCompatibleWith</span>(contentType)) {
    reader = new InputStreamReader(inputMessage<span class="preprocessor">.getBody</span>(), charset)<span class="comment">;</span>
    JsonFormat<span class="preprocessor">.parser</span>()
            <span class="preprocessor">.ignoringUnknownFields</span>()            //忽略未知字段，避免反序列化抛异常
            <span class="preprocessor">.merge</span>(reader, ex)<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h5 id="序列化">序列化</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>HttpOutputMessage outputMessage<span class="comment">;</span>
OutputStreamWriter outputStreamWriter<span class="comment">;</span>
if (MediaType<span class="preprocessor">.APPLICATION</span>_JSON<span class="preprocessor">.isCompatibleWith</span>(contentType)) {
    outputStreamWriter = new OutputStreamWriter(outputMessage<span class="preprocessor">.getBody</span>(), charset)<span class="comment">;</span>
    JsonFormat<span class="preprocessor">.printer</span>()
            <span class="preprocessor">.includingDefaultValueFields</span>()      //默认值也要序列化，兼容接口定义，int类型默认值<span class="number">0</span>也要输出
            <span class="preprocessor">.preservingProtoFieldNames</span>()        //保留原有字段名，兼容接口定义
            <span class="preprocessor">.omittingInsignificantWhitespace</span>()  //忽略空格和换行
            <span class="preprocessor">.appendTo</span>(message, outputStreamWriter)<span class="comment">;</span>
    outputStreamWriter<span class="preprocessor">.flush</span>()<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h4 id="实践">实践</h4>
<ul>
<li><p>接口升级不要修改已有字段的tags，通常采用追加模式，<code>reserved</code> 关键字用来声明保留字段。</p>
</li>
<li><p>可以合理利用map类型。</p>
</li>
<li><p>了解<a href="https://github.com/grpc" target="_blank" rel="external">gRPC</a></p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>由于接口同时支持<code>application/x-protobuf</code>和<code>application/json</code>两种<code>content-type</code>，所以<code>protobuf-java</code>提供的JSON序列化方案性能也是我们比较关注的。</p>
<p>最近注意到<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="external">Protocol Buffers 3</a>（下称proto3）中对JSON的处理调整为利用Gson实现，尝试升级到proto3，这里简单总结下中间遇到的一些问题。</p>
<h4 id="proto3语法规则">proto3语法规则</h4>
<ul>
<li><p>描述文件头部增加语法声明<code>syntax = &quot;proto3&quot;</code> ，这样<code>protoc</code>会正确编译生成代码。</p>
</li>
<li><p>移除<code>required</code>描述关键字，字段默认是<code>optional</code>。</p>
</li>
<li><p>移除<code>default</code>选项，proto2可以使用<code>default</code>为某一字段指定默认值，但proto3字段的默认值只能根据字段类型由系统决定。</p>
</li>
<li><p>enum类型第一个字段的字段编号tags必须为0。</p>
</li>
<li><p>添加新的字段选项<code>json_name</code>。默认在proto3的JSON格式中字段名将被转换为<code>lowerCamelCase</code>，这个选项被用于自定义字段名。</p>
</li>
</ul>
]]></summary>
    
      <category term="Protobuf" scheme="http://liubaing.com/tags/Protobuf/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nexus私服搭建]]></title>
    <link href="http://liubaing.com/2016/11/08/Nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>http://liubaing.com/2016/11/08/Nexus私服搭建/</id>
    <published>2016-11-08T06:33:26.000Z</published>
    <updated>2016-11-08T11:15:08.000Z</updated>
    <content type="html"><![CDATA[<p>Nexus是Maven仓库管理工具，Team内部之前存在一套，但管理比较混乱，这段时间腾出手来重新搭了一套，把整个过程记录下。</p>
<h5 id="下载解压">下载解压</h5>
<p>我这里出现ssl链接问题，所以加了—no-check-certificate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>cd /opt/
wget --no-check-certificate https://sonatype-download<span class="preprocessor">.global</span><span class="preprocessor">.ssl</span><span class="preprocessor">.fastly</span><span class="preprocessor">.net</span>/nexus/oss/nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>-bundle<span class="preprocessor">.zip</span>
unzip nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>-bundle<span class="preprocessor">.zip</span>
ln -s nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>/ nexus
</pre></td></tr></table></figure>

<h5 id="修改-bashrc文件增加环境变量">修改.bashrc文件增加环境变量</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="setting">NEXUS_HOME=<span class="value"><span class="string">"/opt/nexus"</span></span></span>
</pre></td></tr></table></figure>

<h5 id="配置为Service">配置为Service</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>ln <span class="operator">-s</span> <span class="variable">$NEXUS_HOME</span>/bin/nexus /etc/init.d/nexus
<span class="built_in">cd</span> /etc/init.d/
<span class="built_in">sudo</span> chkconfig --add nexus
<span class="built_in">sudo</span> chkconfig --levels <span class="number">345</span> nexus on
</pre></td></tr></table></figure>

<a id="more"></a>

<h5 id="处理权限">处理权限</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>groupadd nexus
useradd <span class="attribute">-g</span> nexus nexus
cd /opt<span class="subst">/</span>
chown <span class="attribute">-R</span> nexus:nexus nexus
chown <span class="attribute">-R</span> nexus:nexus nexus<span class="subst">-</span><span class="number">2.14</span><span class="number">.1</span><span class="subst">-</span><span class="number">01</span><span class="subst">/</span>
chown <span class="attribute">-R</span> nexus:nexus sonatype<span class="attribute">-work</span><span class="subst">/</span>
</pre></td></tr></table></figure>

<h5 id="配置Nginx代理">配置Nginx代理</h5>
<p>Nexus默认的context path是/nexus，如果使用Nginx代理访问，<br>需要修改<code>$NEXUS_HOME/conf/nexus.properties</code>将<code>nexus-webapp-context-path=/nexus</code>改为<code>nexus-webapp-context-path=/</code>，<br>否则通过Nginx访问Nexus会出现登陆不了的情况。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>http {

    proxy_send_timeout <span class="number">120</span>;
    proxy_<span class="built_in">read</span>_timeout <span class="number">300</span>;
    proxy_buffering    off;
    keepalive_timeout  <span class="number">5</span> <span class="number">5</span>;
    tcp_nodelay        on;

    server {
        listen   *:<span class="number">80</span>;
        server_name  repo.example.com;

        <span class="comment"># allow large uploads of files - refer to nginx documentation</span>
        client_max_body_size <span class="number">1</span>G;

        <span class="comment"># optimize downloading files larger than 1G - refer to nginx doc before adjusting</span>
        <span class="comment">#proxy_max_temp_file_size 2G;</span>

        location / {
            proxy_pass http://localhost:<span class="number">8081</span>/;
            proxy_<span class="keyword">set</span>_header Host <span class="variable">$host</span>;
            proxy_<span class="keyword">set</span>_header X-Real-IP <span class="variable">$remote_addr</span>;
            proxy_<span class="keyword">set</span>_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;
        }
    }
}
</pre></td></tr></table></figure>

<h5 id="启动Nexus服务，通过域名访问">启动Nexus服务，通过域名访问</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">sudo</span> service nexus start
</pre></td></tr></table></figure>

<h5 id="配置LDAP">配置LDAP</h5>
<p>让同学们都有各自权限来使用Nexus，但这个是麻烦SA同学帮忙配置的。需要的同学可以参考 <a href="http://blog.sina.com.cn/s/blog_6b89db7a0101g8na.html" target="_blank" rel="external">Sonatype Nexus的LDAP配置指导书</a></p>
<h5 id="修改settings-xml">修改settings.xml</h5>
]]></content>
    <summary type="html"><![CDATA[<p>Nexus是Maven仓库管理工具，Team内部之前存在一套，但管理比较混乱，这段时间腾出手来重新搭了一套，把整个过程记录下。</p>
<h5 id="下载解压">下载解压</h5>
<p>我这里出现ssl链接问题，所以加了—no-check-certificate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>cd /opt/
wget --no-check-certificate https://sonatype-download<span class="preprocessor">.global</span><span class="preprocessor">.ssl</span><span class="preprocessor">.fastly</span><span class="preprocessor">.net</span>/nexus/oss/nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>-bundle<span class="preprocessor">.zip</span>
unzip nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>-bundle<span class="preprocessor">.zip</span>
ln -s nexus-<span class="number">2.14</span><span class="number">.1</span>-<span class="number">01</span>/ nexus
</pre></td></tr></table></figure>

<h5 id="修改-bashrc文件增加环境变量">修改.bashrc文件增加环境变量</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="setting">NEXUS_HOME=<span class="value"><span class="string">"/opt/nexus"</span></span></span>
</pre></td></tr></table></figure>

<h5 id="配置为Service">配置为Service</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>ln <span class="operator">-s</span> <span class="variable">$NEXUS_HOME</span>/bin/nexus /etc/init.d/nexus
<span class="built_in">cd</span> /etc/init.d/
<span class="built_in">sudo</span> chkconfig --add nexus
<span class="built_in">sudo</span> chkconfig --levels <span class="number">345</span> nexus on
</pre></td></tr></table></figure>

]]></summary>
    
      <category term="Maven" scheme="http://liubaing.com/tags/Maven/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用OpenResty解决IP反作弊]]></title>
    <link href="http://liubaing.com/2016/06/25/%E5%88%A9%E7%94%A8OpenResty%E8%A7%A3%E5%86%B3IP%E5%8F%8D%E4%BD%9C%E5%BC%8A/"/>
    <id>http://liubaing.com/2016/06/25/利用OpenResty解决IP反作弊/</id>
    <published>2016-06-25T08:19:29.000Z</published>
    <updated>2016-07-04T08:46:12.000Z</updated>
    <content type="html"><![CDATA[<p>广告投放项目中Nginx起初有通过<code>ngx_http_limit_req_module</code>和<code>ngx_stream_limit_conn_module</code>配置来限制单个IP在同一时间段的访问和并发次数来防止CC攻击，但在解决一些作弊流量上有些力不从心了。</p>
<p>比如有些IP的在没有展示或者展示时间过短的的情况下，模拟客户端(点击触摸参数宏替换)请求广告点击链接，之前这些非法流量是在离线处理才会过滤掉，没有及时的禁止访问，直接导致这些流量可能会被上游DSP反作弊命中影响收入，所以最近着手处理这个问题。</p>
<p>目前的解决思路是，首先收集到异常IP列表入Redis并设置过期时间，在Nginx上利用Lua判断当前IP是否在黑名单中，从而达到反作弊功能。</p>
<a id="more"></a>

<p>确定思路后，在测试环境搭建环境，Google下找到几个方案，对比之后感觉 <a href="http://openresty.org" target="_blank" rel="external">OpenResty</a> 可以满足，里面包含了需要的<code>Nginx</code> <code>Lua</code> <code>Redis</code>模块，且文档比较详细。</p>
<p>具体的安装方法，在 <a href="http://openresty.org" target="_blank" rel="external">OpenResty</a> 有详细的说明，下面简单列出来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="char">$ </span>yum install readline-devel pcre-devel openssl-devel gcc
<span class="char">$ </span>wget <span class="method">https:</span>//openresty.org/download/openresty-<span class="number">1.9</span><span class="number">.15</span><span class="number">.1</span>.tar.gz
<span class="char">$ </span>tar xvf openresty-<span class="number">1.9</span><span class="number">.15</span><span class="number">.1</span>.tar.gz
<span class="char">$ </span>cd openresty-<span class="number">1.9</span><span class="number">.15</span><span class="number">.1</span>
<span class="char">$ </span>./configure
<span class="char">$ </span>make
<span class="char">$ </span>make install
</pre></td></tr></table></figure>

<p>安装之后，会在 <code>/usr/local/openresty</code> 下面生成相关的文件，下面会有一个 <code>/usr/local/openresty/nginx/sbin/nginx</code>，我们可以使用这个来做代理。</p>
<p>修改<code>nginx.conf</code>来让Lua大施拳脚。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">server</span> {
    listen      <span class="number">80</span>;
    server_name xxx;
    location /lua {
            default_type <span class="string">'text/plain'</span>;
            content_by_lua <span class="string">'ngx.say("hello, lua")'</span>;
    }
    location / {
            proxy_pass http:<span class="comment">//127.0.0.1:8080;</span>
            access_log off;
            access_by_lua_file /opt/script/lua/block_ip.lua;
    }
}
</pre></td></tr></table></figure>

<p>启动<code>Nginx</code>，访问//xxx/lua，响应中出现<code>hello, lua</code>说明配置生效，接下来把脚本放到指定目录就应该可以来。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="built_in">local</span> redis = <span class="built_in">require</span> <span class="string">"resty.redis"</span>
<span class="built_in">local</span> cache = redis.<span class="built_in">new</span>()
<span class="built_in">local</span> ok , err = cache.connect(cache,<span class="string">"127.0.0.1"</span>,<span class="string">"6381"</span>)
cache:set_timeout(<span class="number">600</span>)

<span class="keyword">if</span> <span class="operator">not</span> ok <span class="keyword">then</span>
  goto Lastend
<span class="function"><span class="keyword">end</span></span>

is_forbidden, err = cache:<span class="built_in">get</span>(<span class="string">"engine:block:ip:"</span>..ngx.var.remote_addr)

<span class="keyword">if</span> is_forbidden == <span class="string">'1'</span> <span class="keyword">then</span>
  ngx.exit(ngx.HTTP_FORBIDDEN)
  goto Lastend
<span class="function"><span class="keyword">end</span></span>

::Lastend::
<span class="built_in">local</span> ok, err = cache:<span class="built_in">close</span>()
</pre></td></tr></table></figure>

<p>异常IP收集入Redis后，访问返回403，IP的key过期后恢复访问，简单的反作弊算是基本完成了，下一步了继续优化。</p>
<hr>
<p>[2016-07-04]更新：</p>
<p>考虑到<code>Redis</code>单点压力，决定利用<code>Nginx</code>共享来做多级缓存，<code>Lua</code>脚本调整后如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="built_in">local</span> redis = <span class="built_in">require</span> <span class="string">"resty.redis"</span>

<span class="comment">--nginx.conf 配置lua_shared_dict RBL 64m;</span>
<span class="built_in">local</span> cache_ngx = ngx.shared.RBL

<span class="comment">--查询ip是否在封禁段内，若在则返回403错误代码</span>
<span class="built_in">local</span> key = <span class="string">"engine:block:ip:"</span>..ngx.var.remote_addr
<span class="built_in">local</span> <span class="built_in">value</span> = cache_ngx:<span class="built_in">get</span>(key)
<span class="keyword">if</span> <span class="built_in">value</span> == <span class="string">'1'</span> <span class="keyword">then</span>
	ngx.<span class="built_in">log</span>(ngx.WARN, <span class="string">"被Nginx缓存命中拦截的IP: "</span> .. key)
	ngx.exit(ngx.HTTP_FORBIDDEN)
<span class="keyword">else</span>
	<span class="built_in">local</span> cache_rds = redis.<span class="built_in">new</span>()
	<span class="built_in">local</span> ok , err = cache_rds.connect(cache_rds, <span class="string">"127.0.0.1"</span>, <span class="string">"6381"</span>)
	<span class="keyword">if</span> <span class="operator">not</span> ok <span class="keyword">then</span>
		ngx.<span class="built_in">log</span>(ngx.WARN, <span class="string">"Redis获取链接异常: "</span> .. err)
  	<span class="keyword">else</span>
  		cache_rds:set_timeout(<span class="number">600</span>)
		<span class="built_in">value</span> = cache_rds:<span class="built_in">get</span>(key)
		<span class="keyword">if</span> <span class="built_in">value</span> == <span class="string">'1'</span> <span class="keyword">then</span>
			ngx.<span class="built_in">log</span>(ngx.WARN, <span class="string">"被Redis缓存命中拦截的IP: "</span> .. key)
			<span class="comment">--回写nginx，设置expires2分钟</span>
			cache_ngx:<span class="built_in">set</span>(key, <span class="built_in">value</span>, <span class="number">120</span>)
			ngx.exit(ngx.HTTP_FORBIDDEN)
		<span class="function"><span class="keyword">end</span></span>
	<span class="function"><span class="keyword">end</span></span>
	<span class="built_in">local</span> ok, err = cache_rds:<span class="built_in">close</span>()
<span class="function"><span class="keyword">end</span></span>
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>广告投放项目中Nginx起初有通过<code>ngx_http_limit_req_module</code>和<code>ngx_stream_limit_conn_module</code>配置来限制单个IP在同一时间段的访问和并发次数来防止CC攻击，但在解决一些作弊流量上有些力不从心了。</p>
<p>比如有些IP的在没有展示或者展示时间过短的的情况下，模拟客户端(点击触摸参数宏替换)请求广告点击链接，之前这些非法流量是在离线处理才会过滤掉，没有及时的禁止访问，直接导致这些流量可能会被上游DSP反作弊命中影响收入，所以最近着手处理这个问题。</p>
<p>目前的解决思路是，首先收集到异常IP列表入Redis并设置过期时间，在Nginx上利用Lua判断当前IP是否在黑名单中，从而达到反作弊功能。</p>
]]></summary>
    
      <category term="Nginx" scheme="http://liubaing.com/tags/Nginx/"/>
    
      <category term="Lua" scheme="http://liubaing.com/tags/Lua/"/>
    
      <category term="Redis" scheme="http://liubaing.com/tags/Redis/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初次接触Go编程踩到的坑]]></title>
    <link href="http://liubaing.com/2016/05/19/%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6Go%E7%BC%96%E7%A8%8B%E8%B8%A9%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://liubaing.com/2016/05/19/初次接触Go编程踩到的坑/</id>
    <published>2016-05-19T09:58:35.000Z</published>
    <updated>2016-05-19T10:51:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近想利用Go来写切图服务，没什么经验，遇到的问题比较多，下面就简单总结下，看到的同学们可以参考下吧。</p>
<h3 id="1-_设置HTTP_response_header不生效">1. 设置HTTP response header不生效</h3>
<p>由于响应的数据格式为JSON，所以想设置下<code>Content-Type : application/json</code>，代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>w<span class="preprocessor">.WriteHeader</span>(http<span class="preprocessor">.StatusOK</span>)
w<span class="preprocessor">.Header</span>()<span class="preprocessor">.Set</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
</pre></td></tr></table></figure>

<p>结果在Header始终看不到期望结果，跟踪源码发现<code>response</code>中有<code>wroteHeader</code>字段标示。<br>得出结论，如果这两行代码都需要调用，就必须让 w.WriteHeader 在所有的 w.Header.Set 之后执行，才能生效。</p>
<a id="more"></a>

<h3 id="2-_执行os-MkdirAll(&quot;xx/xx/&quot;,_0666)_返回_permission_denied错误">2. 执行<code>os.MkdirAll(&quot;xx/xx/&quot;, 0666)</code> 返回 <code>permission denied</code>错误</h3>
<p>在<code>$HOME</code>目录下，本地执行Shell命令<code>mkdir -p xx/xx/</code>却成功创建，更改第二个参数<code>FileMode</code>为<code>os.ModePerm</code>也无济于事。<br>Google各种搜索后，尝试增加了两行代码，解决了问题，但目前还不清楚为什么，待解。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>mask := <span class="keyword">syscall</span>.Umask(<span class="number">0</span>)
defer <span class="keyword">syscall</span>.Umask(mask)
</pre></td></tr></table></figure>

<h3 id="3-_切图后image保存到本地抛出invalid_memory_address_or_nil_pointer_dereference异常">3. 切图后<code>image</code>保存到本地抛出<code>invalid memory address or nil pointer dereference</code>异常</h3>
<p>经过切图后得到<code>thumb image.Image</code>对象，已经定义好保存路径<code>thumbPath string</code>，保存到本地代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>buffer := new(bytes<span class="preprocessor">.Buffer</span>)
if err := jpeg<span class="preprocessor">.Encode</span>(buffer, thumb, nil)<span class="comment">; err != nil {</span>
    log<span class="preprocessor">.Fatalln</span>(<span class="string">"unable to encode image."</span>)
}
_ = ioutil<span class="preprocessor">.WriteFile</span>(thumbPath, buffer<span class="preprocessor">.Bytes</span>(), <span class="number">0666</span>)
</pre></td></tr></table></figure><br>在上传JPG图片是运行良好，但在处理PNG格式的图片时，出现error，解决方案是增加<br><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">import</span> <span class="params">(<span class="variable">_</span><span class="string">"image/png"</span>)</span></span>
</pre></td></tr></table></figure>


<h3 id="4-_保存原图内容为空">4. 保存原图内容为空</h3>
<p>保存原图时，想通过md5得到HASH字符串的文件名，之后再把文件保存在指定目录下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>md5h := md5<span class="preprocessor">.New</span>()
io<span class="preprocessor">.Copy</span>(md5h, file)
name := hex<span class="preprocessor">.EncodeToString</span>(md5h<span class="preprocessor">.Sum</span>([]byte(<span class="string">""</span>)))
</pre></td></tr></table></figure>

<p>结果发现保存的原图内容是0字节，怀疑就是这里把文件流读到末尾了。<br>改造代码就是在保存图片前调用<code>file.Seek(0, 0)</code>，把<code>offset</code>设置为0恢复文件流。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近想利用Go来写切图服务，没什么经验，遇到的问题比较多，下面就简单总结下，看到的同学们可以参考下吧。</p>
<h3 id="1-_设置HTTP_response_header不生效">1. 设置HTTP response header不生效</h3>
<p>由于响应的数据格式为JSON，所以想设置下<code>Content-Type : application/json</code>，代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>w<span class="preprocessor">.WriteHeader</span>(http<span class="preprocessor">.StatusOK</span>)
w<span class="preprocessor">.Header</span>()<span class="preprocessor">.Set</span>(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
</pre></td></tr></table></figure>

<p>结果在Header始终看不到期望结果，跟踪源码发现<code>response</code>中有<code>wroteHeader</code>字段标示。<br>得出结论，如果这两行代码都需要调用，就必须让 w.WriteHeader 在所有的 w.Header.Set 之后执行，才能生效。</p>
]]></summary>
    
      <category term="Go" scheme="http://liubaing.com/tags/Go/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多线程顺序输出字符]]></title>
    <link href="http://liubaing.com/2016/01/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6/"/>
    <id>http://liubaing.com/2016/01/22/多线程顺序输出字符/</id>
    <published>2016-01-22T05:27:48.000Z</published>
    <updated>2016-04-19T10:14:54.000Z</updated>
    <content type="html"><![CDATA[<p>题目：有多个线程，要求按顺序输出a-z，结果为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[A]</span>
<span class="attr_selector">[Thread-2]</span> <span class="tag">print</span> <span class="attr_selector">[B]</span>
<span class="attr_selector">[Thread-3]</span> <span class="tag">print</span> <span class="attr_selector">[C]</span>
<span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[D]</span>
<span class="attr_selector">[Thread-2]</span> <span class="tag">print</span> <span class="attr_selector">[E]</span>
<span class="attr_selector">[Thread-3]</span> <span class="tag">print</span> <span class="attr_selector">[F]</span>
<span class="attr_selector">[Thread-1]</span> <span class="tag">print</span> <span class="attr_selector">[G]</span>
…
</pre></td></tr></table></figure>

<p>实现代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.Queue;
<span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;
<span class="keyword">import</span> java.util.concurrent.Semaphore;

<span class="javadoc">/**
 * 多线程顺序输出字符队列
 *
 *<span class="javadoctag"> @author</span> heshuai
 *<span class="javadoctag"> @version</span> 16/1/20.
 */</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span> {</span>

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">3</span>;

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Queue&lt;Character&gt; CHARACTER_QUEUE = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="string">'Z'</span> - <span class="string">'A'</span> + <span class="number">1</span>);

    <span class="keyword">static</span> {
        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'A'</span>; c &lt;= <span class="string">'Z'</span>; c++) {
            CHARACTER_QUEUE.add(c);
        }
    }

    <span class="keyword">static</span> class Worker extends Thread {

        <span class="keyword">private</span> Semaphore curSemaphore;
        <span class="keyword">private</span> Semaphore nextSemaphore;

        <span class="keyword">public</span> <span class="title">Worker</span>(<span class="keyword">int</span> index, Semaphore curSemaphore, Semaphore nextSemaphore) {
            <span class="keyword">this</span>.setName(<span class="string">"Thread-"</span> + index);
            <span class="keyword">this</span>.curSemaphore = curSemaphore;
            <span class="keyword">this</span>.nextSemaphore = nextSemaphore;
        }

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {
            <span class="keyword">while</span> (!CHARACTER_QUEUE.isEmpty()) {
                <span class="keyword">try</span> {
                    curSemaphore.acquire();
                    Character character = CHARACTER_QUEUE.poll();
                    <span class="keyword">if</span> (character == <span class="keyword">null</span>) {
                        <span class="keyword">break</span>;
                    }
                    System.out.println(<span class="string">"["</span> + <span class="keyword">this</span>.getName() + <span class="string">"] print ["</span> + character + <span class="string">"]"</span>);
                } <span class="keyword">catch</span> (Exception e) {
                    <span class="comment">//ignore</span>
                } <span class="keyword">finally</span> {
                    nextSemaphore.release();
                }
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Semaphore[] semaphores = <span class="keyword">new</span> Semaphore[THREAD_COUNT];
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) {
            semaphores[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);
        }

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_COUNT; i++) {
            <span class="comment">//先确保Thread-1执行</span>
            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) {
                <span class="keyword">try</span> {
                    semaphores[i - <span class="number">1</span>].acquire();
                } <span class="keyword">catch</span> (Exception e) {
                    <span class="comment">//ignore</span>
                }
            }
            <span class="keyword">if</span> (i &lt; THREAD_COUNT) {
                <span class="keyword">new</span> Worker(i, semaphores[i - <span class="number">1</span>], semaphores[i]).start();
            } <span class="keyword">else</span> {
                <span class="keyword">new</span> Worker(i, semaphores[i - <span class="number">1</span>], semaphores[<span class="number">0</span>]).start();
            }
        }
    }
}
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat优化]]></title>
    <link href="http://liubaing.com/2015/09/09/Tomcat%E4%BC%98%E5%8C%96/"/>
    <id>http://liubaing.com/2015/09/09/Tomcat优化/</id>
    <published>2015-09-09T10:06:36.000Z</published>
    <updated>2017-03-02T11:45:12.000Z</updated>
    <content type="html"><![CDATA[<p>更新：建议部署APM工具<a href="https://github.com/naver/pinpoint" target="_blank" rel="external">Pinpoint</a>，比较直观分析性能。</p>
<p>这几天晚高峰报警比较多，先排查JVM</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="preprocessor"># jstat -gcutil $PID            注意GC次数，过多的GC会影响延迟</span>
<span class="preprocessor"># jmap -heap $PID               观察各个分区的内存占用情况</span>
<span class="preprocessor"># jmap -histo $PID | more       注意大对象或者对象实例较多的情况</span>
<span class="preprocessor"># jstack $PID &gt; jstack.txt      观察线程执行状态，出现线程Block，需要特别注意</span>
</pre></td></tr></table></figure>

<p>ThreadDump没什么问题，GC没发现严重问题，只是觉得Eden区内存设置有点紧张，再排查负载</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="preprocessor"># uptime        观察最近的负载</span>
<span class="preprocessor"># free -g       还有可用内存，注意swap</span>
<span class="preprocessor"># ps auxxwf     各个进程，包括JVM占用资源，可能其他进程的CPU负载过高也会影响响应的延迟，比如日志压缩脚本</span>
<span class="preprocessor"># top           注：按下数字1，观察每个CPU核的负载</span>
<span class="preprocessor"># ss -an | grep :8080 | wc -l   当前端口下的连接数，不区分状态</span>
<span class="preprocessor"># netstat -natl | awk '{print $6}' | sort | uniq -c | sort -n   注意各个状态下的连接数，过多的wait连接影响新的请求进来</span>
</pre></td></tr></table></figure>

<p>发现TIME_WAIT状态的连接比较多，接近配置的连接数上限了，怀疑没有配置keep-alive导致Tomcat主动关闭Connection。</p>
<blockquote>
<p>主动关闭方在接收到被动关闭方的FIN请求后，发送成功给对方一个ACK，并将状态由FIN_WAIT2修改为TIME_WAIT，但是需要等2倍的MSL（Maximum Segment Lifetime，MSL是一个数据包存在于互联网系统中的最大时间）时间之后才能把状态改为CLOSED。</p>
</blockquote>
<p>再结合Nginx和Tomcat的日志，开始着手调整。</p>
<h3 id="Nginx配置keep-alive">Nginx配置keep-alive</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>location / {
    proxy_pass tomcat-upstream;
    proxy_http_version <span class="number">1.1</span>;
    proxy_set_header Connection <span class="string">""</span>;
    <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<h3 id="JVM参数">JVM参数</h3>
<p>在脚本中头部增加一行参数，这里针对JDK8版本的JVM，具体参考<a href="">JVM参数设置及优化</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor"># vim /usr/local/tomcat/bin/catalina.sh</span>
JAVA_OPTS=<span class="string">"-server -Xmx6g -Xms4g -XX:MetaspaceSize=128M -XX:NewRatio=2 -XX:SurvivorRatio=20 -XX:+DisableExplicitGC -XX:+HeapDumpOnOutOfMemoryError"</span>
</pre></td></tr></table></figure>


<h3 id="Connector协议由BIO调整为NIO">Connector协议由BIO调整为NIO</h3>
<h5 id="配置Connector">配置Connector</h5>
<p>同时也参考 <a href="https://tomcat.apache.org/tomcat-8.0-doc/config" target="_blank" rel="external">Tomcat 8 Configuration Reference</a> 修改了线程数和Logs格式，便于统计平均响应时长。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="xml"># vim /usr/local/tomcat/conf/server.xml
<span class="tag">&lt;<span class="title">Connector</span> <span class="attribute">port</span>=<span class="value">"8080"</span> <span class="attribute">protocol</span>=<span class="value">"org.apache.coyote.http11.Http11NioProtocol"</span>
            <span class="attribute">keepAliveTimeout</span>=<span class="value">"60000"</span>
            <span class="attribute">maxKeepAliveRequests</span>=<span class="value">"1024"</span>
            &lt;!<span class="attribute">--</span> 非异步<span class="attribute">Servlet</span>时与<span class="attribute">maxThreads</span>保持一致 <span class="attribute">--</span>&gt;</span>
            processorCache="128"
            maxThreads="128"
            <span class="comment">&lt;!-- 队列大小 --&gt;</span>
            acceptCount="64"
            <span class="comment">&lt;!-- 单位毫秒，请求连接超时，keepAliveTimeout参数未设置按此参数 --&gt;</span>
            connectionTimeout="2000"
            redirectPort="8443" /&gt;

<span class="tag">&lt;<span class="title">Valve</span> <span class="attribute">className</span>=<span class="value">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attribute">directory</span>=<span class="value">"logs"</span>
            <span class="attribute">prefix</span>=<span class="value">"localhost_access_log"</span> <span class="attribute">suffix</span>=<span class="value">".txt"</span>
            <span class="attribute">pattern</span>=<span class="value">"%h %l %u %t &quot;%r&quot; %s %D"</span> /&gt;</span></span>
</pre></td></tr></table></figure>

<p>这里通过<code>jstack</code>结果分析，决定线程<code>maxThreads</code>参数配置，同时也需要考虑栈空间的分配问题。<br>调整过程中也建议使用ab简单压测下，及时观察调整效果。</p>
]]></content>
    
    
      <category term="Nginx" scheme="http://liubaing.com/tags/Nginx/"/>
    
      <category term="Tomcat" scheme="http://liubaing.com/tags/Tomcat/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排查Java进程CPU占有率高]]></title>
    <link href="http://liubaing.com/2015/07/27/%E6%8E%92%E6%9F%A5Java%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E6%9C%89%E7%8E%87%E9%AB%98/"/>
    <id>http://liubaing.com/2015/07/27/排查Java进程CPU占有率高/</id>
    <published>2015-07-27T08:35:56.000Z</published>
    <updated>2015-07-27T09:16:00.000Z</updated>
    <content type="html"><![CDATA[<p>最近尝试在项目中利用<code>com.sun.management.OperatingSystemMXBean</code>增加些调试信息，发现测试环境Java进程CPU占有率很高，Google后总结一些解决过程。</p>
<p>1.根据top命令，发现占有率高的Java的PID。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="preprocessor">#top</span>
</pre></td></tr></table></figure>


<p>2.找到该PID后，首先显示线程列表，并按照CPU占用高的线程排序。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">#ps</span> <span class="attribute">-mp</span> <span class="variable">$PID</span> <span class="attribute">-o</span> <span class="keyword">THREAD</span>,tid,time <span class="subst">|</span> sort <span class="attribute">-rn</span>
</pre></td></tr></table></figure>


<p>3.然后找到耗时最多的线程TID，将需要的TID转换为16进制格式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">#printf</span> <span class="comment">"%x\n"</span> <span class="char">$T</span>ID
</pre></td></tr></table></figure>


<p>4.打印线程的堆栈信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="symbol">#jstack</span> <span class="char">$P</span>ID |grep <span class="char">$0</span>xTID -<span class="class">A</span> <span class="number">30</span>
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="Linux" scheme="http://liubaing.com/tags/Linux/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL JDBC Driver版本Bug]]></title>
    <link href="http://liubaing.com/2015/07/21/MySQL-JDBC-Driver%E7%89%88%E6%9C%ACBug/"/>
    <id>http://liubaing.com/2015/07/21/MySQL-JDBC-Driver版本Bug/</id>
    <published>2015-07-21T09:12:15.000Z</published>
    <updated>2015-07-21T09:53:30.000Z</updated>
    <content type="html"><![CDATA[<p>上周发现线上的CTR信息不准确，影响到广告投放概率。</p>
<p>经过同事的排查发现是数据库实例连接错了，在jdbcUrl中指定的端口是是3307，但实际上是读写3306默认端口的数据库。</p>
<p>跟踪确定是Driver本身的Bug，Google了下官方已经有<a href="https://bugs.mysql.com/bug.php?id=47494" target="_blank" rel="external">相关Bug反馈</a>了，解决方案就是把mysql-connector-java的版本从5.1.9调整为5.1.18。</p>
]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web下文件下载]]></title>
    <link href="http://liubaing.com/2014/12/10/Web%E4%B8%8B%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <id>http://liubaing.com/2014/12/10/Web下文件下载/</id>
    <published>2014-12-10T02:45:20.000Z</published>
    <updated>2014-12-10T11:19:16.000Z</updated>
    <content type="html"><![CDATA[<p>下载中文名文件，这个场景在很多Web下经常遇到。</p>
<p>普遍思路，保存文件重命名，记录下原文件名，待用户下载时，response header种设置下原文件名。</p>
<p>需要注意的是，考虑到浏览器兼容问题，文件名不仅要URLEncode编码处理，还需要遵循<a href="http://tools.ietf.org/html/rfc2231" target="_blank" rel="external">RFC 2231</a>，参数Key后增加星号，Value前面为字符集和单引号中的语言，比如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Content-disposition: attachment;filename<span class="variable">*=</span>utf-<span class="number">8</span><span class="string">'zh_cn'</span><span class="variable">%e4</span><span class="variable">%b8</span><span class="variable">%ad</span><span class="variable">%e6</span><span class="variable">%96</span><span class="variable">%87</span>.pdf
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的单例模式]]></title>
    <link href="http://liubaing.com/2014/10/19/Java%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://liubaing.com/2014/10/19/Java中的单例模式/</id>
    <published>2014-10-19T10:28:54.000Z</published>
    <updated>2014-10-19T14:39:16.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式是Java设计模式中相当经典的了，平时工作接触的也只有懒汉、饿汉之类的，之前阿里面试中也被问到这个问题，今天就总结一下。</p>
<h4 id="饿汉式">饿汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>一般不希望在类加载时就创建对象，改进后：</p>
<h4 id="简单实现线程安全的懒汉式">简单实现线程安全的懒汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> synchronized Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>上面例子的性能不太理想，其实只需第一次调用时同步，利用JDK1.5中volatile关键字改进后：<br><a id="more"></a></p>
<p><h4>利用volatile的懒汉式</h4></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            synchronized (Singleton.class) {
                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
                    instance = <span class="keyword">new</span> Singleton();
                }
            }
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<h4 id="利用枚举类">利用枚举类</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">enum</span> Singleton {
    INSTANCE;
}
</pre></td></tr></table></figure>

<h4 id="利用内部类机制实现">利用内部类机制实现</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {

    <span class="keyword">private</span> <span class="title">Singleton</span>() { }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> SingletonHolder {
        <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> SingletonHolder.INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>总结下，尽管上面列举一些方法实现单例，但还是不完全能保证，还需要注意反序列化和反射。个人推荐枚举方式，代码量简介而且很好利用JVM。</p>
]]></content>
    <summary type="html"><![CDATA[<p>单例模式是Java设计模式中相当经典的了，平时工作接触的也只有懒汉、饿汉之类的，之前阿里面试中也被问到这个问题，今天就总结一下。</p>
<h4 id="饿汉式">饿汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> final <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {
        <span class="keyword">return</span> INSTANCE;
    }
}
</pre></td></tr></table></figure>

<p>一般不希望在类加载时就创建对象，改进后：</p>
<h4 id="简单实现线程安全的懒汉式">简单实现线程安全的懒汉式</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Singleton {
    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;

    <span class="keyword">private</span> <span class="title">Singleton</span>() {
    }

    <span class="keyword">public</span> <span class="keyword">static</span> synchronized Singleton <span class="title">getInstance</span>() {
        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {
            instance = <span class="keyword">new</span> Singleton();
        }
        <span class="keyword">return</span> instance;
    }
}
</pre></td></tr></table></figure>

<p>上面例子的性能不太理想，其实只需第一次调用时同步，利用JDK1.5中volatile关键字改进后：<br>]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中常用的时间格式化注意点]]></title>
    <link href="http://liubaing.com/2014/09/18/Java%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://liubaing.com/2014/09/18/Java中常用的时间格式化注意点/</id>
    <published>2014-09-18T09:29:24.000Z</published>
    <updated>2015-07-27T08:41:57.000Z</updated>
    <content type="html"><![CDATA[<p>平时工作中或多或少都会遇到时间格式化的问题，传统思路都利用<code>java.text.SimpleDateFormat</code>，然后根据业务场景写几个Pattern去处理。</p>
<p>之前接触到项目中一般都会提供一个工具类，既然是工具类，那就按套路了，上面声明几个不同格式的Pattern实例，下面写几个static方法，然后处理下异常之类的。</p>
<p>这样的好处是避免方法调用时去new SimpleDateFormat，从而创建大量的实例对象，毕竟SimpleDateFormat类初始化代价不小，父类DateFormat中成员变量包含Calendar等。</p>
<p>但恰恰就因为这个成员变量，并且format方法又没有同步，所以这个工具类在多线程下风险很高。</p>
<p>这个问题在网上也看到很多解决方案，参考JDK中注释。</p>
<blockquote>
<p> Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally</p>
</blockquote>
<h4 id="同步SimpleDateFormat对象">同步SimpleDateFormat对象</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) <span class="keyword">throws</span> ParseException {
    <span class="keyword">synchronized</span>(sdf) {
        <span class="keyword">return</span> sdf.format(date);
    }
}
</pre></td></tr></table></figure><br>同步随之而来就是阻塞</p>
<h4 id="使用ThreadLocal">使用ThreadLocal</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> final String FULL_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;
<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();

<span class="keyword">public</span> <span class="keyword">static</span> SimpleDateFormat <span class="title">getDateFormat</span>() {
    SimpleDateFormat dateFormat = threadLocal.<span class="keyword">get</span>();
    <span class="keyword">if</span> (dateFormat == <span class="keyword">null</span>) {
        dateFormat = <span class="keyword">new</span> SimpleDateFormat(FULL_DATE_FORMAT);
        threadLocal.<span class="keyword">set</span>(dateFormat);
    }
    <span class="keyword">return</span> dateFormat;
}

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) throws ParseException {
    <span class="keyword">return</span> getDateFormat().format(date);
}
</pre></td></tr></table></figure><br>共享变量变成了线程私有</p>
<a id="more"></a>

<h4 id="使用Joda-Time类库">使用Joda-Time类库</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FULL_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(DateTime dateTime) {
    <span class="keyword">return</span> dateTime.toString(FULL_DATE_FORMAT);
}
</pre></td></tr></table></figure><br>对用户自定义Pattern，Joda在解析并创建<code>org.joda.time.format.DateTimeFormatter</code>会Cache，不用过于担心性能问题，当然也自己手动去Cache，因为DateTime有多个toString()重载方法。</p>
]]></content>
    <summary type="html"><![CDATA[<p>平时工作中或多或少都会遇到时间格式化的问题，传统思路都利用<code>java.text.SimpleDateFormat</code>，然后根据业务场景写几个Pattern去处理。</p>
<p>之前接触到项目中一般都会提供一个工具类，既然是工具类，那就按套路了，上面声明几个不同格式的Pattern实例，下面写几个static方法，然后处理下异常之类的。</p>
<p>这样的好处是避免方法调用时去new SimpleDateFormat，从而创建大量的实例对象，毕竟SimpleDateFormat类初始化代价不小，父类DateFormat中成员变量包含Calendar等。</p>
<p>但恰恰就因为这个成员变量，并且format方法又没有同步，所以这个工具类在多线程下风险很高。</p>
<p>这个问题在网上也看到很多解决方案，参考JDK中注释。</p>
<blockquote>
<p> Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally</p>
</blockquote>
<h4 id="同步SimpleDateFormat对象">同步SimpleDateFormat对象</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) <span class="keyword">throws</span> ParseException {
    <span class="keyword">synchronized</span>(sdf) {
        <span class="keyword">return</span> sdf.format(date);
    }
}
</pre></td></tr></table></figure><br>同步随之而来就是阻塞</p>
<h4 id="使用ThreadLocal">使用ThreadLocal</h4>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> final String FULL_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;
<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();

<span class="keyword">public</span> <span class="keyword">static</span> SimpleDateFormat <span class="title">getDateFormat</span>() {
    SimpleDateFormat dateFormat = threadLocal.<span class="keyword">get</span>();
    <span class="keyword">if</span> (dateFormat == <span class="keyword">null</span>) {
        dateFormat = <span class="keyword">new</span> SimpleDateFormat(FULL_DATE_FORMAT);
        threadLocal.<span class="keyword">set</span>(dateFormat);
    }
    <span class="keyword">return</span> dateFormat;
}

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatDate</span>(Date date) throws ParseException {
    <span class="keyword">return</span> getDateFormat().format(date);
}
</pre></td></tr></table></figure><br>共享变量变成了线程私有</p>
]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用浏览器下调试]]></title>
    <link href="http://liubaing.com/2014/07/26/%E5%B8%B8%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%B0%83%E8%AF%95/"/>
    <id>http://liubaing.com/2014/07/26/常用浏览器下调试/</id>
    <published>2014-07-26T07:41:31.000Z</published>
    <updated>2015-09-09T04:48:27.000Z</updated>
    <content type="html"><![CDATA[<p>2015-9-9更新：<br>Android设备进入开发者选项，启用USB调试后，Terminal输入</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>heshuai-<span class="constant">MacBookPro</span><span class="symbol">:~</span> heshuai<span class="variable">$ </span>adb devices
<span class="constant">List</span> of devices attached
<span class="number">01</span>ce8d6a1858745f	device
</pre></td></tr></table></figure><br>检查设备是否成功连接，然后在Chrome 45在地址栏输入 <code>chrome://inspect/</code></p>
<p><img src="http://7j1y6m.com1.z0.glb.clouddn.com/chrome-inspect.png" alt="chrome://inspect/"><br>应该能看到当前连接的设备，找到要调试页面，点击inspect即可</p>
<p><em>注：无需安装Chrome（Android 版）</em></p>
<hr>
<p><strong>Safari</strong>下显示开发者调试工具方法:<br>Preferences - Advanced - Show Develop menu in menu bar</p>
<p><strong>Firefox</strong>本身包含开发者工具，当然Firebug插件大家更常用。</p>
<p><strong>Chrome</strong>下默认的Inspect Element(以下测试均在Chrome Version 36.0.1985.125下)</p>
<h2 id="Console">Console</h2>
<p>使用alert调试在迭代输出时很不方便，这时利用log可以很直观的观察运行状态。</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&gt; console.<span class="keyword">log</span>(<span class="string">'hello world'</span>);
  hello world
&gt; console.<span class="keyword">warn</span>(<span class="string">'warning info'</span>);
&gt; console.<span class="keyword">warn</span>(<span class="string">'error message'</span>)
</pre></td></tr></table></figure><br>平时在Sources标签下对JS方法设置断点Debug时，可以查看作用域内的变量，也可以利用在Console中直接输入变量名查看。</p>
<a id="more"></a>

<h2 id="Emulation">Emulation</h2>
<p>用来调试移动网站的利器，可以模拟移动设备分辨率，UA等，还可以模拟传感器，比如经纬度。</p>
<h2 id="Network">Network</h2>
<p>在这里罗列了当前页所有的HTTP请求，注意Status和Timeline用来作为优化请求的参考标准。<br>点击每条请求能看到请求头、请求参数、响应头、响应内容等信息，比如AJAX请求中比较关注的Content-Type字段。</p>
<h2 id="Resources">Resources</h2>
<p>一般常用就是Cookies标签，可以手动清除部分Cookie。<br>现在很多站点也开始采用H5中的Storage，在这里也可以查看并手动编辑。</p>
<h2 id="Elements">Elements</h2>
<p>查看页面节点信息，可以手动调整DOM，也可以更改CSS，观察渲染样式，查看节点监听事件。</p>
]]></content>
    <summary type="html"><![CDATA[<p>2015-9-9更新：<br>Android设备进入开发者选项，启用USB调试后，Terminal输入</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>heshuai-<span class="constant">MacBookPro</span><span class="symbol">:~</span> heshuai<span class="variable">$ </span>adb devices
<span class="constant">List</span> of devices attached
<span class="number">01</span>ce8d6a1858745f	device
</pre></td></tr></table></figure><br>检查设备是否成功连接，然后在Chrome 45在地址栏输入 <code>chrome://inspect/</code></p>
<p><img src="http://7j1y6m.com1.z0.glb.clouddn.com/chrome-inspect.png" alt="chrome://inspect/"><br>应该能看到当前连接的设备，找到要调试页面，点击inspect即可</p>
<p><em>注：无需安装Chrome（Android 版）</em></p>
<hr>
<p><strong>Safari</strong>下显示开发者调试工具方法:<br>Preferences - Advanced - Show Develop menu in menu bar</p>
<p><strong>Firefox</strong>本身包含开发者工具，当然Firebug插件大家更常用。</p>
<p><strong>Chrome</strong>下默认的Inspect Element(以下测试均在Chrome Version 36.0.1985.125下)</p>
<h2 id="Console">Console</h2>
<p>使用alert调试在迭代输出时很不方便，这时利用log可以很直观的观察运行状态。</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&gt; console.<span class="keyword">log</span>(<span class="string">'hello world'</span>);
  hello world
&gt; console.<span class="keyword">warn</span>(<span class="string">'warning info'</span>);
&gt; console.<span class="keyword">warn</span>(<span class="string">'error message'</span>)
</pre></td></tr></table></figure><br>平时在Sources标签下对JS方法设置断点Debug时，可以查看作用域内的变量，也可以利用在Console中直接输入变量名查看。</p>
]]></summary>
    
      <category term="Android" scheme="http://liubaing.com/tags/Android/"/>
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP常见乱码问题]]></title>
    <link href="http://liubaing.com/2014/06/27/HTTP%E5%B8%B8%E8%A7%81%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://liubaing.com/2014/06/27/HTTP常见乱码问题/</id>
    <published>2014-06-27T07:42:03.000Z</published>
    <updated>2015-07-20T07:41:22.000Z</updated>
    <content type="html"><![CDATA[<p>众所周知，乱码问题源于编码不一致，往往在平时开发中容易忽略指明编码，而依赖于默认编码。</p>
<p>比如使用Spring MVC时需要配置org.springframework.http.converter.StringHttpMessageConverter的defaultCharset；<br>还有使用HttpClient时注意响应中ByteArray反序列化时也要指明charsetName，否则读取JVM参数file.encoding。</p>
<p>总结下就是一般输入输出流尽量指明编码，防止出现环境不一样导致乱码问题。</p>
]]></content>
    
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="HTTP" scheme="http://liubaing.com/tags/HTTP/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[龙泉驾校约车脚本]]></title>
    <link href="http://liubaing.com/2014/06/18/%E9%BE%99%E6%B3%89%E9%A9%BE%E6%A0%A1%E7%BA%A6%E8%BD%A6%E8%84%9A%E6%9C%AC/"/>
    <id>http://liubaing.com/2014/06/18/龙泉驾校约车脚本/</id>
    <published>2014-06-18T08:20:49.000Z</published>
    <updated>2014-09-19T03:08:08.000Z</updated>
    <content type="html"><![CDATA[<p>最近该学科目二，可一连几天都约不上车，开始琢磨写个脚本，看有没有效果。<br><a id="more"></a></p>
<p>抱怨驾校也是徒劳，谁让当时图便宜呢。脚本也是参考了其他同学的代码，调整后不是特别完善，不过龙泉的校友还是可以参考。</p>
<p>下面是执行脚本，其中有些参数根据自己情况填写：</p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="comment"># !/usr/bin/python</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> lqjx
<span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

logging.basicConfig(level=logging.DEBUG,
                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,
                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>)

<span class="comment">#约车时段，全部、上午8-12、下午1-5、晚上5-8</span>
xnsd = (<span class="string">"-1"</span>, <span class="string">"812"</span>, <span class="string">"15"</span>, <span class="string">"58"</span>)
<span class="comment">#指定想约的教练</span>
jlcbh = <span class="string">""</span>
uname = <span class="string">""</span>
passwd = <span class="string">""</span>

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    lq = lqjx.LQJX()
    <span class="keyword">try</span>:
        <span class="keyword">if</span> lq.login(uname, passwd):
            <span class="keyword">while</span> <span class="number">1</span>:
                cars = lq.get_bookable_car(xnsd[<span class="number">1</span>])
                <span class="keyword">if</span> <span class="string">'null_0'</span> <span class="keyword">in</span> cars:
                    logging.info(<span class="string">'没到时间或者没有可预订车辆！'</span>)
                <span class="keyword">else</span>:
                    result = lq.order_car(xnsd[<span class="number">1</span>], jlcbh)
                    <span class="keyword">print</span> result
                    <span class="keyword">if</span> <span class="string">u'成功'</span> <span class="keyword">in</span> result:
                        logging.info(<span class="string">'\n 预定成功！'</span>)
                        sys.exit(<span class="number">0</span>)
                <span class="comment">#增加间隔时间，防止频繁请求，账号被封</span>
                time.sleep(<span class="number">30</span>)
    <span class="keyword">except</span> KeyboardInterrupt:
        lq.logout()
        logging.info(<span class="string">'退出约车系统！'</span>)
</pre></td></tr></table></figure>

<p>下面是核心模块：</p>
<p><a id="more"></a></p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="code"><pre><span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> requests
<span class="keyword">import</span> datetime
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

LQJX_HOST = <span class="string">"http://106.37.230.254:81"</span>
lq_session = requests.Session()


<span class="class"><span class="keyword">class</span> <span class="title">LQJX</span>:</span>

    header = {
        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36'</span>
    }

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        <span class="keyword">pass</span>

    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self, uname, passwd)</span>:</span>
        post_data = {
            <span class="string">'__VIEWSTATE'</span>: <span class="string">'/wEPDwUKMTg0NDI4MDE5OGRkj8OrkkOlfYqdhxkeEVV4GsZ6FLw0IioIcl+nbwqoGbo='</span>,
            <span class="string">'__EVENTVALIDATION'</span>: <span class="string">'/wEWBgKF6pivDAKl1bKzCQK1qbSRCwLoyMm8DwLi44eGDAKAv7D9Co04a1vpmJ/QuWDi2GFypJ8LBXRdxHsgxKaj/eIzgMJ6'</span>,
            <span class="string">'txtUserName'</span>: uname,
            <span class="string">'txtPassword'</span>: passwd,
            <span class="string">'BtnLogin'</span>: <span class="string">'登  录'</span>,
            <span class="string">'rcode'</span>: <span class="string">''</span>
        }
        result = lq_session.post(LQJX_HOST + <span class="string">'/login.aspx'</span>, data=post_data, headers=self.header)
        <span class="keyword">if</span> <span class="string">'zhxx.aspx'</span> <span class="keyword">in</span> result.text:
            logging.info(<span class="string">"登录成功!"</span>)
            flag = <span class="keyword">True</span>
        <span class="keyword">else</span>:
            logging.error(<span class="string">"登录失败，请检查账号状态或请求参数!"</span>)
            flag = <span class="keyword">False</span>
        <span class="keyword">return</span> flag

    <span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">(self)</span>:</span>
        lq_session.get(LQJX_HOST + <span class="string">'/Login.aspx?LoginOut=true'</span>, headers=self.header)

    <span class="function"><span class="keyword">def</span> <span class="title">order_car</span><span class="params">(self, xnsd, jlcbh)</span>:</span>
        query_param = {
            <span class="string">'jlcbh'</span>: jlcbh,  <span class="comment">#教练场编号</span>
            <span class="string">'yyrqbegin'</span>: str(datetime.date.today() + datetime.timedelta(<span class="number">13</span>)).replace(<span class="string">'-'</span>, <span class="string">''</span>),  <span class="comment">#预约14天后</span>
            <span class="string">'xnsd'</span>: xnsd,  <span class="comment">#时段 -1  812  15  58</span>
            <span class="string">'trainType'</span>: <span class="string">'3'</span>,  <span class="comment">#原地1 道路3 实际4</span>
            <span class="string">'type'</span>: <span class="string">'km2Car2'</span>,  <span class="comment">#约车类型 科目二km2Car2</span>
            <span class="string">'_'</span>: int(time.time())  <span class="comment">#时间戳</span>
        }
        <span class="keyword">return</span> lq_session.get(LQJX_HOST + <span class="string">"/Tools/km2.aspx?"</span>, params=query_param, headers=self.header).text

    <span class="function"><span class="keyword">def</span> <span class="title">get_bookable_car</span><span class="params">(self, xnsd)</span>:</span>
        base_url = LQJX_HOST + <span class="string">"/Tools/km2.aspx?date="</span> + str(datetime.datetime.now())
        query_param = {
            <span class="string">'filters[yyrq]'</span>: str(datetime.date.today() + datetime.timedelta(<span class="number">13</span>)).replace(<span class="string">'-'</span>, <span class="string">''</span>),
            <span class="string">'filters[xnsd]'</span>: xnsd,
            <span class="string">'filters[xllxid]'</span>: <span class="string">'3'</span>,
            <span class="string">'filters[type]'</span>: <span class="string">'km2Car'</span>,
            <span class="string">'filters[cnbh]'</span>: <span class="string">''</span>, <span class="comment">#场内编号，不填写则为全部</span>
            <span class="string">'pageno'</span>: <span class="string">'1'</span>,
            <span class="string">'pagesize'</span>: <span class="string">'30'</span>,
            <span class="string">'_'</span>: int(time.time())
        }
        <span class="keyword">return</span> lq_session.get(base_url, params=query_param).text

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="keyword">pass</span>
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>最近该学科目二，可一连几天都约不上车，开始琢磨写个脚本，看有没有效果。<br><!--more--></p>
<p>抱怨驾校也是徒劳，谁让当时图便宜呢。脚本也是参考了其他同学的代码，调整后不是特别完善，不过龙泉的校友还是可以参考。</p>
<p>下面是执行脚本，其中有些参数根据自己情况填写：</p>
<figure class="highlight {python}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="comment"># !/usr/bin/python</span>
<span class="comment"># -*- coding: utf-8 -*-</span>

<span class="keyword">import</span> lqjx
<span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">import</span> logging

logging.basicConfig(level=logging.DEBUG,
                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,
                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>)

<span class="comment">#约车时段，全部、上午8-12、下午1-5、晚上5-8</span>
xnsd = (<span class="string">"-1"</span>, <span class="string">"812"</span>, <span class="string">"15"</span>, <span class="string">"58"</span>)
<span class="comment">#指定想约的教练</span>
jlcbh = <span class="string">""</span>
uname = <span class="string">""</span>
passwd = <span class="string">""</span>

<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    lq = lqjx.LQJX()
    <span class="keyword">try</span>:
        <span class="keyword">if</span> lq.login(uname, passwd):
            <span class="keyword">while</span> <span class="number">1</span>:
                cars = lq.get_bookable_car(xnsd[<span class="number">1</span>])
                <span class="keyword">if</span> <span class="string">'null_0'</span> <span class="keyword">in</span> cars:
                    logging.info(<span class="string">'没到时间或者没有可预订车辆！'</span>)
                <span class="keyword">else</span>:
                    result = lq.order_car(xnsd[<span class="number">1</span>], jlcbh)
                    <span class="keyword">print</span> result
                    <span class="keyword">if</span> <span class="string">u'成功'</span> <span class="keyword">in</span> result:
                        logging.info(<span class="string">'\n 预定成功！'</span>)
                        sys.exit(<span class="number">0</span>)
                <span class="comment">#增加间隔时间，防止频繁请求，账号被封</span>
                time.sleep(<span class="number">30</span>)
    <span class="keyword">except</span> KeyboardInterrupt:
        lq.logout()
        logging.info(<span class="string">'退出约车系统！'</span>)
</pre></td></tr></table></figure>

<p>下面是核心模块：</p>
<p>]]></summary>
    
      <category term="Python" scheme="http://liubaing.com/tags/Python/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[世界杯直播]]></title>
    <link href="http://liubaing.com/2014/06/15/%E4%B8%96%E7%95%8C%E6%9D%AF%E7%9B%B4%E6%92%AD/"/>
    <id>http://liubaing.com/2014/06/15/世界杯直播/</id>
    <published>2014-06-15T03:10:39.000Z</published>
    <updated>2016-11-10T08:36:22.000Z</updated>
    <content type="html"><![CDATA[<p>感谢世界杯给我们带来如此精彩的比赛，感谢CCTV节目组和解说嘉宾，更要感谢我们身边那个支持我们熬夜看球的人，但不用谢我，我只是搬运工。<br><a id="more"></a></p>
<iframe height="408" width="510" src="http://static.youku.com/v1.0.0550/v/swf/livePlayer.swf?autoplay=1&showlogo=0&channel=204" frameborder="0" allowfullscreen></iframe>

<p>今天是父亲节，在此借助世界杯祝愿天下所有父亲身体健康，感谢生命中有您的陪伴！</p>
]]></content>
    <summary type="html"><![CDATA[<p>感谢世界杯给我们带来如此精彩的比赛，感谢CCTV节目组和解说嘉宾，更要感谢我们身边那个支持我们熬夜看球的人，但不用谢我，我只是搬运工。<br>]]></summary>
    
      <category term="扯淡" scheme="http://liubaing.com/categories/%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[翻墙]]></title>
    <link href="http://liubaing.com/2014/06/13/%E7%BF%BB%E5%A2%99/"/>
    <id>http://liubaing.com/2014/06/13/翻墙/</id>
    <published>2014-06-13T08:38:14.000Z</published>
    <updated>2016-11-10T08:36:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近Google访问不了，各种403和连接被重置。<br><a id="more"></a><br>这给平时工作带来很大的不便，至于原因大家心知肚明。</p>
<p>之前由于改过hosts，遇到Google被墙对自己影响不大，但这次彻底歇菜了。</p>
<p>选择VPN还得取决所在网络环境，L2TP方式经常连接不上，所以暂时先Pass。看微博上有推荐用SSH代理，去淘宝上搜了一家，10块一月，感觉价格可以接受，还是香港主机，下单吧。</p>
<p>跟大家分享Mac下的方法，首先打开终端输入</p>
<p><figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ssh <span class="attribute">-qTfnNv</span> <span class="attribute">-D</span> <span class="number">7070</span> username@host
</pre></td></tr></table></figure><br>输入密码后在网络设置中增加代理，这里选择SOCKS Proxy，输入127.0.0.1:7070后点击应用。</p>
<p><img src="http://liubaing.qiniudn.com/ssh_proxy.jpeg" alt="增加代理"></p>
<p>现在，打开浏览器试试吧！</p>
<hr>
<p>2014-6-19更新：</p>
<p>提供新版<a href="http://liubaing.qiniudn.com/hosts" target="_blank" rel="external">hosts</a>下载，大家自测。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近Google访问不了，各种403和连接被重置。<br>]]></summary>
    
      <category term="VPN" scheme="http://liubaing.com/tags/VPN/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git日常操作]]></title>
    <link href="http://liubaing.com/2014/05/02/Git%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/"/>
    <id>http://liubaing.com/2014/05/02/Git日常操作/</id>
    <published>2014-05-02T07:05:24.000Z</published>
    <updated>2016-01-19T03:09:57.000Z</updated>
    <content type="html"><![CDATA[<p>平时使用git依赖于IDE图形化界面插件，用起来倒没什么问题，但觉得还是有必要总结下常用的git命令，<a href="http://git-scm.com/book/zh" target="_blank" rel="external">点击查看Git中文文档</a>。</p>
<p>一般我们clone已有的项目，默认就是git协议，URL后面可以指定目录：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>liubaing/galaxy.git galaxy
</pre></td></tr></table></figure>

<p>如果本地已经存在的项目</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git init
</pre></td></tr></table></figure>

<p>这时我们发现本地仓库有个隐藏目录.git，里面通常会有：</p>
<p>工作目录(working directory)我们实际持有的文件；<br>缓存区(index/stage)临时保存我们所做的修改；<br>HEAD指向我们最后一次提交的结果。</p>
<p>整个变化过程是这样的：working directory -&gt; “git add” -&gt; index -&gt; “git commit” -&gt; HEAD</p>
<a id="more"></a>


<p>本地默认会创建一个master分支，拿平时开发项目为例，我们还需要建立MS分支：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>$ git checkout <span class="attribute">-b</span> vs<span class="attribute">-ezine</span><span class="subst">-</span><span class="number">4.2</span><span class="number">.0</span><span class="attribute">-MS20140702</span> <span class="variable">#branch</span>为要切换的目的分支
Switched <span class="keyword">to</span> a <span class="literal">new</span> branch <span class="string">'vs-ezine-4.2.0-MS20140702'</span>
</pre></td></tr></table></figure>

<p>现在我们来看下本地分支:</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$ git branch <span class="attribute">-av</span> 查看所有分支，PS大家表邪恶
  master
<span class="subst">*</span> vs<span class="attribute">-ezine</span><span class="subst">-</span><span class="number">4.2</span><span class="number">.0</span><span class="attribute">-MS20140702</span>
</pre></td></tr></table></figure>

<p>开发过程中需要提交时：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="variable">$ </span>git mv 重命名，这块在<span class="constant">OSX</span>下会有文件名大小写的问题
<span class="variable">$ </span>git pull 更新代码
<span class="variable">$ </span>git status  查看当前分支的状态，是否有冲突或未提交的文件
<span class="variable">$ </span>git log  查看当前分支的commit log，看看是否与远程分支一致
<span class="variable">$ </span>git add -<span class="constant">A</span>
<span class="variable">$ </span>git commit -m <span class="string">"xxx"</span>
<span class="variable">$ </span>git push origin vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span><span class="symbol">:vs-ezine-</span><span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span>
</pre></td></tr></table></figure>

<p>开发过程中文件撤销有几种方式：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>$ git reset HEAD &lt;file&gt;<span class="keyword">...</span>  保留本地修改，取消index
$ git checkout - &lt;file&gt;<span class="keyword">...</span>  放弃本地修改，将index移到working directory
$ git reset –hard &lt;commit-id&gt;  回退到某个commit-id，包括commit/index信息
$ git reset –soft &lt;commit-id&gt;  回退到某个commit-id，只是commit不包括index
</pre></td></tr></table></figure>

<p>开发结束后要把分支代码合并到master，并删除分支：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="variable">$ </span>git checkout master
<span class="variable">$ </span>git merge vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span>
<span class="variable">$ </span>git branch -<span class="constant">D</span> vs-ezine-<span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span> <span class="comment">#注意：这是是强制删除，但尽量不能删除当前分支，分支如果有commit未合并也不要删除</span>
<span class="variable">$ </span>git push origin <span class="symbol">:vs-ezine-</span><span class="number">4.2</span>.<span class="number">0</span>-<span class="constant">MS20140702</span> <span class="comment">#删除远程分支</span>
</pre></td></tr></table></figure>]]></content>
    <summary type="html"><![CDATA[<p>平时使用git依赖于IDE图形化界面插件，用起来倒没什么问题，但觉得还是有必要总结下常用的git命令，<a href="http://git-scm.com/book/zh" target="_blank" rel="external">点击查看Git中文文档</a>。</p>
<p>一般我们clone已有的项目，默认就是git协议，URL后面可以指定目录：</p>
<figure class="highlight {bash}"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span>liubaing/galaxy.git galaxy
</pre></td></tr></table></figure>

<p>如果本地已经存在的项目</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git init
</pre></td></tr></table></figure>

<p>这时我们发现本地仓库有个隐藏目录.git，里面通常会有：</p>
<p>工作目录(working directory)我们实际持有的文件；<br>缓存区(index/stage)临时保存我们所做的修改；<br>HEAD指向我们最后一次提交的结果。</p>
<p>整个变化过程是这样的：working directory -&gt; “git add” -&gt; index -&gt; “git commit” -&gt; HEAD</p>
]]></summary>
    
      <category term="Git" scheme="http://liubaing.com/tags/Git/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linode退钱]]></title>
    <link href="http://liubaing.com/2014/04/12/Linode%E9%80%80%E9%92%B1/"/>
    <id>http://liubaing.com/2014/04/12/Linode退钱/</id>
    <published>2014-04-12T08:13:17.000Z</published>
    <updated>2016-11-10T08:36:22.000Z</updated>
    <content type="html"><![CDATA[<p>之前用过一段时间Linode，不过由于种种原因（其实就是懒）不想继续维护了，Remove掉主机后，它会自动结算剩余金额。也不想让钱那么寂寞的呆在账户里，琢磨怎么退还到信用卡里。<br><a id="more"></a></p>
<p>方法是登录Linode后给Linode客服发ticket申请退款。我直接写了一句 I don’t have time to maintain it and kindly need money，提交，等着收钱。然后客服回复后，退款自生成之日起，要3到5天才能到你的信用卡账户。</p>
<p>退款后，如果你觉得这个账户没有继续存在的必要，那么可以在account选项卡页面的最底部，找到“Cancel this Account”链接，点击即可。</p>
]]></content>
    <summary type="html"><![CDATA[<p>之前用过一段时间Linode，不过由于种种原因（其实就是懒）不想继续维护了，Remove掉主机后，它会自动结算剩余金额。也不想让钱那么寂寞的呆在账户里，琢磨怎么退还到信用卡里。<br>]]></summary>
    
      <category term="扯淡" scheme="http://liubaing.com/categories/%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[集合类源码理解]]></title>
    <link href="http://liubaing.com/2014/03/20/%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <id>http://liubaing.com/2014/03/20/集合类源码理解/</id>
    <published>2014-03-20T10:16:38.000Z</published>
    <updated>2016-06-03T07:09:53.000Z</updated>
    <content type="html"><![CDATA[<p>JDK中提供的集合类一般不外乎就两种数据结构，数组和引用(链表)。</p>
<h3 id="Map">Map</h3>
<h6 id="HashMap">HashMap</h6>
<p>首先要说得HashMap就是数组和链表得结合体，先看源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">/**
 * 默认初始化容量，必须是2的N次方
 */</span>
<span class="keyword">static</span> <span class="keyword">final</span> int DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span>
<span class="keyword">static</span> <span class="keyword">final</span> Entry<span class="preprocessor">&lt;?</span>,<span class="preprocessor">?&gt;</span>[] EMPTY_TABLE = {};
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; {</span>
    <span class="keyword">final</span> K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;
    ......
}
</pre></td></tr></table></figure>

<p>底层就是Entry数组，每个Entry持有next引用，构成链表。<br><a id="more"></a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">public</span> V <span class="title">put</span>(K key, V <span class="keyword">value</span>) {
    <span class="comment">//初次执行创建2的N次方容量的数组</span>
    <span class="keyword">if</span> (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    <span class="comment">//null键直接存在table[0]</span>
    <span class="keyword">if</span> (key == <span class="keyword">null</span>)
        <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);
    <span class="comment">//计算所在数组索引</span>
    <span class="keyword">int</span> hash = hash(key);
    <span class="keyword">int</span> i = indexFor(hash, table.length);
    <span class="comment">//链表头部开始迭代，如果key的hash值和引用同一个对象或者实现equals方法相等，直接替换value，并返回旧value</span>
    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) {
        Object k;
        <span class="keyword">if</span> (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.<span class="keyword">value</span>;
            e.<span class="keyword">value</span> = <span class="keyword">value</span>;
            <span class="comment">//LinkedHashMap维护链表顺序</span>
            e.recordAccess(<span class="keyword">this</span>);
            <span class="keyword">return</span> oldValue;
        }
    }
    <span class="comment">//更改次数，实现fast-fail</span>
    modCount++;
    addEntry(hash, key, <span class="keyword">value</span>, i);
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">void</span> addEntry(<span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex) {
    <span class="comment">//2倍扩容，如果在构造前明确容量需求，尽量指定避免扩容和重新映射</span>
    <span class="keyword">if</span> ((size &gt;= threshold) && (<span class="keyword">null</span> != table[bucketIndex])) {
        resize(<span class="number">2</span> * table.length);
        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, <span class="keyword">value</span>, bucketIndex);
}

<span class="keyword">void</span> createEntry(<span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, <span class="keyword">value</span>, e);
    size++;
}
</pre></td></tr></table></figure>

<p>当我们往HashMap中put元素的时候，计算key的hash值，根据hash值对数组长度取模运算得到在数组中的位置，如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。</p>
<p>前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">final</span> <span class="keyword">int</span> hash(Object k) {
    <span class="keyword">int</span> h = hashSeed;
    <span class="keyword">if</span> (<span class="number">0</span> != h && k <span class="keyword">instanceof</span> String) {
        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();
    <span class="comment">//减少碰撞</span>
    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);
    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);
}

<span class="keyword">static</span> <span class="keyword">int</span> indexFor(<span class="keyword">int</span> h, <span class="keyword">int</span> length) {
    <span class="comment">//注意这里没有采用%，而&实现有个前提length必须是2的N次方，</span>
    <span class="comment">//具体原因网上搜索下后得知 &操作用了3mov+1and+1sub，%操作用了2mov+1cdp+1idiv</span>
    <span class="comment">//前者只需5个CPU周期，而后者至少需要26个CPU周期</span>
    <span class="keyword">return</span> h & (length-<span class="number">1</span>);
}
</pre></td></tr></table></figure>

<p>那之前强调的保证length为2的N次方，原因就是为了充分利用数组空间，元素尽量散列些，具体就是而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1，这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<p>简单理解存取原理后，在我们平时的使用过程中需要注意HashMap是非线程安全的，这个在文档中也有说明，所以要特别注意使用场景，需要的多线程同时读写时可以额外同步<code>Map m = Collections.synchronizedMap(new HashMap(...));</code>，类似于<code>HashTable</code>，不过更推荐使用下面要介绍的的并发Map。</p>
<h6 id="ConcurrentHashMap">ConcurrentHashMap</h6>
<p>看过<code>HashTable</code>源码同学都知道，它完全依赖synchronized关键字来实现线程安全，项目中一般不会采用，更倾向于性能更好的<code>ConcurrentHashMap</code>，这个实现机制我们也看下基本的结构</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;
<span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; {</span>
    <span class="keyword">final</span> <span class="keyword">int</span> hash;
    <span class="keyword">final</span> K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
}
<span class="comment">//类似于HashMap的结构，即内部拥有一个HashEntry数组，数组中的每个元素又是一个单向链表，同时拥有ReentrantLock可重入的互斥锁特性。</span>
<span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">ReentrantLock</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">Serializable</span> {</span>
    transient volatile HashEntry&lt;K,V&gt;[] table;
}
</pre></td></tr></table></figure>

<p>看了基本都明白了，ConcurrentHashMap采用了分段锁的设计，相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力。</p>
<p>不过ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性，HashEntry中的value以及next都被volatile修饰，这样在多线程读写过程中能够保持它们的可见性。</p>
<p>下面来看一下关注下常用的get/put方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre></td><td class="code"><pre><span class="keyword">public</span> V <span class="title">get</span>(Object key) {
    Segment&lt;K,V&gt; s;
    HashEntry&lt;K,V&gt;[] tab;
    <span class="keyword">int</span> h = hash(key);
    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) & segmentMask) &lt;&lt; SSHIFT) + SBASE;
    <span class="comment">//注意一下，这里并没有同步，而是采用UNSAFE本地方法</span>
    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &&
        (tab = s.table) != <span class="keyword">null</span>) {
        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) & h)) &lt;&lt; TSHIFT) + TBASE);
             e != <span class="keyword">null</span>; e = e.next) {
            K k;
            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h && key.equals(k)))
                <span class="keyword">return</span> e.<span class="keyword">value</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="keyword">public</span> V <span class="title">put</span>(K key, V <span class="keyword">value</span>) {
    Segment&lt;K,V&gt; s;
    <span class="comment">//在使用过程中需要注意K/V都不支持null，否则抛NullPointerException</span>
    <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="keyword">null</span>)
        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();
    <span class="keyword">int</span> hash = hash(key);
    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) & segmentMask;
    <span class="comment">//如果找不到该Segment，则新建一个。</span>
    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span>
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">// in ensureSegment</span>
        s = ensureSegment(j);
    <span class="keyword">return</span> s.put(key, hash, <span class="keyword">value</span>, <span class="keyword">false</span>);
}

<span class="comment">//这个是Segment的方法</span>
final V put(K key, <span class="keyword">int</span> hash, V <span class="keyword">value</span>, boolean onlyIfAbsent) {
    <span class="comment">//tryLock()获取锁，获取锁失败的话，则通过scanAndLockForPut()获取锁，并返回要插入的HashEntry。</span>
    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :
        scanAndLockForPut(key, hash, <span class="keyword">value</span>);
    V oldValue;
    <span class="keyword">try</span> {
        HashEntry&lt;K,V&gt;[] tab = table;
        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) & hash;
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) {
            <span class="keyword">if</span> (e != <span class="keyword">null</span>) {
                K k;
                <span class="comment">//当HashEntry中已经包含key时，先保存原有的值。如果onlyIfAbsent为true，即不存在时才插入，则直接退出，否则，用新的value值覆盖。</span>
                <span class="keyword">if</span> ((k = e.key) == key ||
                    (e.hash == hash && key.equals(k))) {
                    oldValue = e.<span class="keyword">value</span>;
                    <span class="keyword">if</span> (!onlyIfAbsent) {
                        e.<span class="keyword">value</span> = <span class="keyword">value</span>;
                        ++modCount;
                    }
                    <span class="keyword">break</span>;
                }
                e = e.next;
            }
            <span class="keyword">else</span> {
                <span class="comment">// 如果node非空，则将node设置链表头，否则，新建HashEntry链表。</span>
                <span class="keyword">if</span> (node != <span class="keyword">null</span>)
                    node.setNext(first);
                <span class="keyword">else</span>
                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, <span class="keyword">value</span>, first);
                <span class="keyword">int</span> c = count + <span class="number">1</span>;
                <span class="comment">//如果添加key-value键值对之后，Segment中的元素超过阈值，并且HashEntry数组的长度没超过限制，2倍rehash；否则，直接添加key-value键值对。</span>
                <span class="keyword">if</span> (c &gt; threshold && tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                <span class="keyword">else</span>
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = <span class="keyword">null</span>;
                <span class="keyword">break</span>;
            }
        }
    } <span class="keyword">finally</span> {
        <span class="comment">// 释放锁</span>
        unlock();
    }
    <span class="keyword">return</span> oldValue;
}
</pre></td></tr></table></figure>

<h3 id="Collection">Collection</h3>
<h4 id="List">List</h4>
<h6 id="ArrayList">ArrayList</h6>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData
</pre></td></tr></table></figure>

<p>底层由数组实现，所以根据index获取元素效率较高，但涉及到<code>System.arraycopy()</code>的方法效率会差些。</p>
<p>这里简单说下平时有在迭代集合是删除元素的需求，一般也知道由于快速失败(fail-fast)策略，不能在迭代时直接调用List<code>remove()</code>方法，只能用Iterator<code>remove()</code>方法，否则会抛出<code>ConcurrentModificationException</code>异常。<br>但这里还有个坑，在迭代到倒数第二个元素时，去调用List<code>remove()</code>方法也不会抛异常，是因为删除元素后列表size直接-1，执行到<code>hasNext()</code>方法是，会直接忽略最后一个元素。</p>
<h6 id="LinkedList">LinkedList</h6>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        <span class="keyword">this</span>.item = element;
        <span class="keyword">this</span>.next = next;
        <span class="keyword">this</span>.prev = prev;
    }
}
</pre></td></tr></table></figure>

<p>双向链表，实现了Deque接口，也能作为队列、栈使用。<br>对比<code>ArrayList</code>，不能笼统说插入、删除效率要高很多，应该是在已知具体<code>node</code>的情况下，只需更改引用即可。</p>
<h4 id="Set">Set</h4>
<h6 id="HashSet">HashSet</h6>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();
</pre></td></tr></table></figure>

<p>底层还是HashMap，只不过所有value都是PRESENT。</p>
<h4 id="Queue">Queue</h4>
<h6 id="ArrayBlockingQueue">ArrayBlockingQueue</h6>
<p>本篇文章中唯一的线程安全的类，平时应用于线程池的任务队列中。<br>既然是Array家族，自然底层也是数组，看下源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">final</span> Object[] items;
<span class="keyword">int</span> takeIndex;
<span class="keyword">int</span> putIndex;
<span class="keyword">int</span> count;

<span class="keyword">final</span> ReentrantLock lock;
<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;
<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;
</pre></td></tr></table></figure>

<p>简单看下出队入队源码说明吧：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="keyword">public</span> E <span class="title">take</span>() throws InterruptedException {
   final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
   <span class="keyword">lock</span>.lockInterruptibly();
   <span class="comment">//锁可中断</span>
   <span class="keyword">try</span> {
       <span class="comment">//如果队列为空，则所有符合此条件的消费者等待，否则取队首元素</span>
       <span class="keyword">while</span> (count == <span class="number">0</span>)               
           notEmpty.<span class="keyword">await</span>();
       <span class="keyword">return</span> extract();
   } <span class="keyword">finally</span> {
       <span class="comment">//finally 解锁。</span>
       <span class="keyword">lock</span>.unlock();
   }
    }

    <span class="keyword">private</span> E <span class="title">extract</span>() {
   final Object[] items = <span class="keyword">this</span>.items;
   E x = <span class="keyword">this</span>.cast(items[takeIndex]);
   <span class="comment">//将元素删除</span>
   items[takeIndex] = <span class="keyword">null</span>;
   <span class="comment">//更新出队索引，如果takeIndex=队列长度，则从0开始循环。</span>
   takeIndex = inc(takeIndex);
   <span class="comment">//当前队列中的元素大小</span>
   --count;
   <span class="comment">//通知生产者</span>
   notFull.signal();
   <span class="comment">//返回元素</span>
        <span class="keyword">return</span> x;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(E e) throws InterruptedException {
   checkNotNull(e);
   final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;
   <span class="keyword">lock</span>.lockInterruptibly();
   <span class="keyword">try</span> {
       <span class="comment">//如果队列已满，所有符合此条件的生产者都等待阻塞。</span>
       <span class="keyword">while</span> (count == items.length)
           notFull.<span class="keyword">await</span>();
         <span class="comment">//入队新元素</span>
              insert(e);
   } <span class="keyword">finally</span> {
       <span class="keyword">lock</span>.unlock();
   }
    }

    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span>(E x) {
   <span class="comment">//添加元素</span>
   items[putIndex] = x;
   <span class="comment">//自增入队索引，如果等于队列长度，从0开始循环。</span>
   putIndex = inc(putIndex);
   <span class="comment">//队列中元素的数量</span>
   ++count;
   <span class="comment">//通知消费</span>
   notEmpty.signal();
    }
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>JDK中提供的集合类一般不外乎就两种数据结构，数组和引用(链表)。</p>
<h3 id="Map">Map</h3>
<h6 id="HashMap">HashMap</h6>
<p>首先要说得HashMap就是数组和链表得结合体，先看源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">/**
 * 默认初始化容量，必须是2的N次方
 */</span>
<span class="keyword">static</span> <span class="keyword">final</span> int DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span>
<span class="keyword">static</span> <span class="keyword">final</span> Entry<span class="preprocessor">&lt;?</span>,<span class="preprocessor">?&gt;</span>[] EMPTY_TABLE = {};
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; {</span>
    <span class="keyword">final</span> K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;
    ......
}
</pre></td></tr></table></figure>

<p>底层就是Entry数组，每个Entry持有next引用，构成链表。<br>]]></summary>
    
      <category term="Java" scheme="http://liubaing.com/tags/Java/"/>
    
      <category term="编程" scheme="http://liubaing.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim基本操作]]></title>
    <link href="http://liubaing.com/2014/03/03/Vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://liubaing.com/2014/03/03/Vim基本操作/</id>
    <published>2014-03-03T03:16:05.000Z</published>
    <updated>2016-11-10T08:19:40.000Z</updated>
    <content type="html"><![CDATA[<p>废话不多说，直入主题吧。</p>
<h4 id="1、平时常用操作">1、平时常用操作</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>vim 启动vim
i 进入插入模式
&lt;<span class="constant">Esc</span>&gt; 进入命令行模式
v 进入可视化模式
<span class="symbol">:w</span> filename （保存文件为<span class="string">"filename"</span>）
<span class="symbol">:q</span> 退出vim
<span class="symbol">:q!</span> 强制退出
<span class="symbol">:w</span> !sudo tee % 权限不足时，强制保存
</pre></td></tr></table></figure>

<h4 id="2、删除">2、删除</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="tag">vim</span> <span class="tag">filename</span>
<span class="pseudo">:set</span> <span class="tag">nu</span> 显示行号
<span class="pseudo">:n</span> 移动到第<span class="tag">n</span>行
<span class="pseudo">:1</span>,5<span class="tag">d</span> 回车后，删除1<span class="tag">-5</span>行
<span class="tag">p</span> 粘贴
<span class="tag">u</span> 恢复
<span class="tag">dG</span> 删除当前行后所有行
<span class="tag">dd</span> 剪切光标所在整行
<span class="tag">dw</span> 删除该单词
<span class="tag">d0</span> 删除该行开始到当前光标
</pre></td></tr></table></figure>

<h4 id="3、移动光标">3、移动光标</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>/kw 向前搜索kw
?kw 向后搜索kw
n 向前匹配kw
<span class="constant">N</span> 向后匹配kw
<span class="number">0</span> 跳到行首
<span class="variable">$ </span>跳到行尾
gg 跳到首行
<span class="constant">G</span> 跳到文件末尾
</pre></td></tr></table></figure>

<h4 id="4、批量加注释">4、批量加注释</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>进入可视化模式(v)
使用上下键（shift可翻页）选择需要注释的多行
进入插入模式(i)
然后输入注释符
进入编辑模式(<span class="tag">&lt;<span class="title">Esc</span>&gt;</span>)
</pre></td></tr></table></figure>

<h4 id="5、替换字符串">5、替换字符串</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>进入可视化模式(v)
选中开始符后按下<span class="escape">`%</span><span class="escape">`直</span>接匹配到结束符，
按下<span class="escape">`d</span><span class="escape">`删</span>除后，按<span class="escape">`i</span><span class="escape">`后</span>粘贴即可
</pre></td></tr></table></figure>]]></content>
    
    
      <category term="Vim" scheme="http://liubaing.com/tags/Vim/"/>
    
      <category term="工具" scheme="http://liubaing.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
